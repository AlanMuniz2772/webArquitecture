(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))n(o);new MutationObserver(o=>{for(const a of o)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&n(i)}).observe(document,{childList:!0,subtree:!0});function s(o){const a={};return o.integrity&&(a.integrity=o.integrity),o.referrerPolicy&&(a.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?a.credentials="include":o.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function n(o){if(o.ep)return;o.ep=!0;const a=s(o);fetch(o.href,a)}})();function Zs(e,t){const s=Object.create(null),n=e.split(",");for(let o=0;o<n.length;o++)s[n[o]]=!0;return t?o=>!!s[o.toLowerCase()]:o=>!!s[o]}const J={},mt=[],Ie=()=>{},wa=()=>!1,Ea=/^on[^a-z]/,ps=e=>Ea.test(e),Gs=e=>e.startsWith("onUpdate:"),se=Object.assign,en=(e,t)=>{const s=e.indexOf(t);s>-1&&e.splice(s,1)},ja=Object.prototype.hasOwnProperty,$=(e,t)=>ja.call(e,t),D=Array.isArray,Lt=e=>hs(e)==="[object Map]",Ca=e=>hs(e)==="[object Set]",N=e=>typeof e=="function",ne=e=>typeof e=="string",ms=e=>typeof e=="symbol",Y=e=>e!==null&&typeof e=="object",go=e=>(Y(e)||N(e))&&N(e.then)&&N(e.catch),qa=Object.prototype.toString,hs=e=>qa.call(e),Pa=e=>hs(e).slice(8,-1),Ra=e=>hs(e)==="[object Object]",tn=e=>ne(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,ts=Zs(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),vs=e=>{const t=Object.create(null);return s=>t[s]||(t[s]=e(s))},Aa=/-(\w)/g,Me=vs(e=>e.replace(Aa,(t,s)=>s?s.toUpperCase():"")),Sa=/\B([A-Z])/g,Et=vs(e=>e.replace(Sa,"-$1").toLowerCase()),gs=vs(e=>e.charAt(0).toUpperCase()+e.slice(1)),Ps=vs(e=>e?`on${gs(e)}`:""),nt=(e,t)=>!Object.is(e,t),Rs=(e,t)=>{for(let s=0;s<e.length;s++)e[s](t)},rs=(e,t,s)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,value:s})},Oa=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let En;const Ls=()=>En||(En=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function sn(e){if(D(e)){const t={};for(let s=0;s<e.length;s++){const n=e[s],o=ne(n)?Ua(n):sn(n);if(o)for(const a in o)t[a]=o[a]}return t}else if(ne(e)||Y(e))return e}const Ia=/;(?![^(]*\))/g,Ma=/:([^]+)/,Ta=/\/\*[^]*?\*\//g;function Ua(e){const t={};return e.replace(Ta,"").split(Ia).forEach(s=>{if(s){const n=s.split(Ma);n.length>1&&(t[n[0].trim()]=n[1].trim())}}),t}function nn(e){let t="";if(ne(e))t=e;else if(D(e))for(let s=0;s<e.length;s++){const n=nn(e[s]);n&&(t+=n+" ")}else if(Y(e))for(const s in e)e[s]&&(t+=s+" ");return t.trim()}const La="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",za=Zs(La);function xo(e){return!!e||e===""}let ve;class Da{constructor(t=!1){this.detached=t,this._active=!0,this.effects=[],this.cleanups=[],this.parent=ve,!t&&ve&&(this.index=(ve.scopes||(ve.scopes=[])).push(this)-1)}get active(){return this._active}run(t){if(this._active){const s=ve;try{return ve=this,t()}finally{ve=s}}}on(){ve=this}off(){ve=this.parent}stop(t){if(this._active){let s,n;for(s=0,n=this.effects.length;s<n;s++)this.effects[s].stop();for(s=0,n=this.cleanups.length;s<n;s++)this.cleanups[s]();if(this.scopes)for(s=0,n=this.scopes.length;s<n;s++)this.scopes[s].stop(!0);if(!this.detached&&this.parent&&!t){const o=this.parent.scopes.pop();o&&o!==this&&(this.parent.scopes[this.index]=o,o.index=this.index)}this.parent=void 0,this._active=!1}}}function Na(e,t=ve){t&&t.active&&t.effects.push(e)}function Fa(){return ve}const on=e=>{const t=new Set(e);return t.w=0,t.n=0,t},bo=e=>(e.w&Xe)>0,yo=e=>(e.n&Xe)>0,$a=({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=Xe},Ha=e=>{const{deps:t}=e;if(t.length){let s=0;for(let n=0;n<t.length;n++){const o=t[n];bo(o)&&!yo(o)?o.delete(e):t[s++]=o,o.w&=~Xe,o.n&=~Xe}t.length=s}},zs=new WeakMap;let It=0,Xe=1;const Ds=30;let ge;const tt=Symbol(""),Ns=Symbol("");class an{constructor(t,s=null,n){this.fn=t,this.scheduler=s,this.active=!0,this.deps=[],this.parent=void 0,Na(this,n)}run(){if(!this.active)return this.fn();let t=ge,s=Ve;for(;t;){if(t===this)return;t=t.parent}try{return this.parent=ge,ge=this,Ve=!0,Xe=1<<++It,It<=Ds?$a(this):jn(this),this.fn()}finally{It<=Ds&&Ha(this),Xe=1<<--It,ge=this.parent,Ve=s,this.parent=void 0,this.deferStop&&this.stop()}}stop(){ge===this?this.deferStop=!0:this.active&&(jn(this),this.onStop&&this.onStop(),this.active=!1)}}function jn(e){const{deps:t}=e;if(t.length){for(let s=0;s<t.length;s++)t[s].delete(e);t.length=0}}let Ve=!0;const _o=[];function jt(){_o.push(Ve),Ve=!1}function Ct(){const e=_o.pop();Ve=e===void 0?!0:e}function pe(e,t,s){if(Ve&&ge){let n=zs.get(e);n||zs.set(e,n=new Map);let o=n.get(s);o||n.set(s,o=on()),wo(o)}}function wo(e,t){let s=!1;It<=Ds?yo(e)||(e.n|=Xe,s=!bo(e)):s=!e.has(ge),s&&(e.add(ge),ge.deps.push(e))}function De(e,t,s,n,o,a){const i=zs.get(e);if(!i)return;let c=[];if(t==="clear")c=[...i.values()];else if(s==="length"&&D(e)){const r=Number(n);i.forEach((f,u)=>{(u==="length"||!ms(u)&&u>=r)&&c.push(f)})}else switch(s!==void 0&&c.push(i.get(s)),t){case"add":D(e)?tn(s)&&c.push(i.get("length")):(c.push(i.get(tt)),Lt(e)&&c.push(i.get(Ns)));break;case"delete":D(e)||(c.push(i.get(tt)),Lt(e)&&c.push(i.get(Ns)));break;case"set":Lt(e)&&c.push(i.get(tt));break}if(c.length===1)c[0]&&Fs(c[0]);else{const r=[];for(const f of c)f&&r.push(...f);Fs(on(r))}}function Fs(e,t){const s=D(e)?e:[...e];for(const n of s)n.computed&&Cn(n);for(const n of s)n.computed||Cn(n)}function Cn(e,t){(e!==ge||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}const Ba=Zs("__proto__,__v_isRef,__isVue"),Eo=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(ms)),qn=ka();function ka(){const e={};return["includes","indexOf","lastIndexOf"].forEach(t=>{e[t]=function(...s){const n=B(this);for(let a=0,i=this.length;a<i;a++)pe(n,"get",a+"");const o=n[t](...s);return o===-1||o===!1?n[t](...s.map(B)):o}}),["push","pop","shift","unshift","splice"].forEach(t=>{e[t]=function(...s){jt();const n=B(this)[t].apply(this,s);return Ct(),n}}),e}function Ka(e){const t=B(this);return pe(t,"has",e),t.hasOwnProperty(e)}class jo{constructor(t=!1,s=!1){this._isReadonly=t,this._shallow=s}get(t,s,n){const o=this._isReadonly,a=this._shallow;if(s==="__v_isReactive")return!o;if(s==="__v_isReadonly")return o;if(s==="__v_isShallow")return a;if(s==="__v_raw"&&n===(o?a?oi:Ro:a?Po:qo).get(t))return t;const i=D(t);if(!o){if(i&&$(qn,s))return Reflect.get(qn,s,n);if(s==="hasOwnProperty")return Ka}const c=Reflect.get(t,s,n);return(ms(s)?Eo.has(s):Ba(s))||(o||pe(t,"get",s),a)?c:re(c)?i&&tn(s)?c:c.value:Y(c)?o?So(c):bs(c):c}}class Co extends jo{constructor(t=!1){super(!1,t)}set(t,s,n,o){let a=t[s];if(xt(a)&&re(a)&&!re(n))return!1;if(!this._shallow&&(!ls(n)&&!xt(n)&&(a=B(a),n=B(n)),!D(t)&&re(a)&&!re(n)))return a.value=n,!0;const i=D(t)&&tn(s)?Number(s)<t.length:$(t,s),c=Reflect.set(t,s,n,o);return t===B(o)&&(i?nt(n,a)&&De(t,"set",s,n):De(t,"add",s,n)),c}deleteProperty(t,s){const n=$(t,s);t[s];const o=Reflect.deleteProperty(t,s);return o&&n&&De(t,"delete",s,void 0),o}has(t,s){const n=Reflect.has(t,s);return(!ms(s)||!Eo.has(s))&&pe(t,"has",s),n}ownKeys(t){return pe(t,"iterate",D(t)?"length":tt),Reflect.ownKeys(t)}}class Wa extends jo{constructor(t=!1){super(!0,t)}set(t,s){return!0}deleteProperty(t,s){return!0}}const Va=new Co,Qa=new Wa,Xa=new Co(!0),rn=e=>e,xs=e=>Reflect.getPrototypeOf(e);function Xt(e,t,s=!1,n=!1){e=e.__v_raw;const o=B(e),a=B(t);s||(nt(t,a)&&pe(o,"get",t),pe(o,"get",a));const{has:i}=xs(o),c=n?rn:s?dn:$t;if(i.call(o,t))return c(e.get(t));if(i.call(o,a))return c(e.get(a));e!==o&&e.get(t)}function Jt(e,t=!1){const s=this.__v_raw,n=B(s),o=B(e);return t||(nt(e,o)&&pe(n,"has",e),pe(n,"has",o)),e===o?s.has(e):s.has(e)||s.has(o)}function Yt(e,t=!1){return e=e.__v_raw,!t&&pe(B(e),"iterate",tt),Reflect.get(e,"size",e)}function Pn(e){e=B(e);const t=B(this);return xs(t).has.call(t,e)||(t.add(e),De(t,"add",e,e)),this}function Rn(e,t){t=B(t);const s=B(this),{has:n,get:o}=xs(s);let a=n.call(s,e);a||(e=B(e),a=n.call(s,e));const i=o.call(s,e);return s.set(e,t),a?nt(t,i)&&De(s,"set",e,t):De(s,"add",e,t),this}function An(e){const t=B(this),{has:s,get:n}=xs(t);let o=s.call(t,e);o||(e=B(e),o=s.call(t,e)),n&&n.call(t,e);const a=t.delete(e);return o&&De(t,"delete",e,void 0),a}function Sn(){const e=B(this),t=e.size!==0,s=e.clear();return t&&De(e,"clear",void 0,void 0),s}function Zt(e,t){return function(n,o){const a=this,i=a.__v_raw,c=B(i),r=t?rn:e?dn:$t;return!e&&pe(c,"iterate",tt),i.forEach((f,u)=>n.call(o,r(f),r(u),a))}}function Gt(e,t,s){return function(...n){const o=this.__v_raw,a=B(o),i=Lt(a),c=e==="entries"||e===Symbol.iterator&&i,r=e==="keys"&&i,f=o[e](...n),u=s?rn:t?dn:$t;return!t&&pe(a,"iterate",r?Ns:tt),{next(){const{value:m,done:h}=f.next();return h?{value:m,done:h}:{value:c?[u(m[0]),u(m[1])]:u(m),done:h}},[Symbol.iterator](){return this}}}}function Be(e){return function(...t){return e==="delete"?!1:this}}function Ja(){const e={get(a){return Xt(this,a)},get size(){return Yt(this)},has:Jt,add:Pn,set:Rn,delete:An,clear:Sn,forEach:Zt(!1,!1)},t={get(a){return Xt(this,a,!1,!0)},get size(){return Yt(this)},has:Jt,add:Pn,set:Rn,delete:An,clear:Sn,forEach:Zt(!1,!0)},s={get(a){return Xt(this,a,!0)},get size(){return Yt(this,!0)},has(a){return Jt.call(this,a,!0)},add:Be("add"),set:Be("set"),delete:Be("delete"),clear:Be("clear"),forEach:Zt(!0,!1)},n={get(a){return Xt(this,a,!0,!0)},get size(){return Yt(this,!0)},has(a){return Jt.call(this,a,!0)},add:Be("add"),set:Be("set"),delete:Be("delete"),clear:Be("clear"),forEach:Zt(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(a=>{e[a]=Gt(a,!1,!1),s[a]=Gt(a,!0,!1),t[a]=Gt(a,!1,!0),n[a]=Gt(a,!0,!0)}),[e,s,t,n]}const[Ya,Za,Ga,ei]=Ja();function ln(e,t){const s=t?e?ei:Ga:e?Za:Ya;return(n,o,a)=>o==="__v_isReactive"?!e:o==="__v_isReadonly"?e:o==="__v_raw"?n:Reflect.get($(s,o)&&o in n?s:n,o,a)}const ti={get:ln(!1,!1)},si={get:ln(!1,!0)},ni={get:ln(!0,!1)},qo=new WeakMap,Po=new WeakMap,Ro=new WeakMap,oi=new WeakMap;function ai(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function ii(e){return e.__v_skip||!Object.isExtensible(e)?0:ai(Pa(e))}function bs(e){return xt(e)?e:cn(e,!1,Va,ti,qo)}function Ao(e){return cn(e,!1,Xa,si,Po)}function So(e){return cn(e,!0,Qa,ni,Ro)}function cn(e,t,s,n,o){if(!Y(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const a=o.get(e);if(a)return a;const i=ii(e);if(i===0)return e;const c=new Proxy(e,i===2?n:s);return o.set(e,c),c}function ht(e){return xt(e)?ht(e.__v_raw):!!(e&&e.__v_isReactive)}function xt(e){return!!(e&&e.__v_isReadonly)}function ls(e){return!!(e&&e.__v_isShallow)}function Oo(e){return ht(e)||xt(e)}function B(e){const t=e&&e.__v_raw;return t?B(t):e}function Io(e){return rs(e,"__v_skip",!0),e}const $t=e=>Y(e)?bs(e):e,dn=e=>Y(e)?So(e):e;function Mo(e){Ve&&ge&&(e=B(e),wo(e.dep||(e.dep=on())))}function To(e,t){e=B(e);const s=e.dep;s&&Fs(s)}function re(e){return!!(e&&e.__v_isRef===!0)}function ri(e){return Uo(e,!1)}function li(e){return Uo(e,!0)}function Uo(e,t){return re(e)?e:new ci(e,t)}class ci{constructor(t,s){this.__v_isShallow=s,this.dep=void 0,this.__v_isRef=!0,this._rawValue=s?t:B(t),this._value=s?t:$t(t)}get value(){return Mo(this),this._value}set value(t){const s=this.__v_isShallow||ls(t)||xt(t);t=s?t:B(t),nt(t,this._rawValue)&&(this._rawValue=t,this._value=s?t:$t(t),To(this))}}function vt(e){return re(e)?e.value:e}const di={get:(e,t,s)=>vt(Reflect.get(e,t,s)),set:(e,t,s,n)=>{const o=e[t];return re(o)&&!re(s)?(o.value=s,!0):Reflect.set(e,t,s,n)}};function Lo(e){return ht(e)?e:new Proxy(e,di)}class ui{constructor(t,s,n,o){this._setter=s,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this._dirty=!0,this.effect=new an(t,()=>{this._dirty||(this._dirty=!0,To(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!o,this.__v_isReadonly=n}get value(){const t=B(this);return Mo(t),(t._dirty||!t._cacheable)&&(t._dirty=!1,t._value=t.effect.run()),t._value}set value(t){this._setter(t)}}function fi(e,t,s=!1){let n,o;const a=N(e);return a?(n=e,o=Ie):(n=e.get,o=e.set),new ui(n,o,a||!o,s)}function Qe(e,t,s,n){let o;try{o=n?e(...n):e()}catch(a){ys(a,t,s)}return o}function _e(e,t,s,n){if(N(e)){const a=Qe(e,t,s,n);return a&&go(a)&&a.catch(i=>{ys(i,t,s)}),a}const o=[];for(let a=0;a<e.length;a++)o.push(_e(e[a],t,s,n));return o}function ys(e,t,s,n=!0){const o=t?t.vnode:null;if(t){let a=t.parent;const i=t.proxy,c=s;for(;a;){const f=a.ec;if(f){for(let u=0;u<f.length;u++)if(f[u](e,i,c)===!1)return}a=a.parent}const r=t.appContext.config.errorHandler;if(r){Qe(r,null,10,[e,i,c]);return}}pi(e,s,o,n)}function pi(e,t,s,n=!0){console.error(e)}let Ht=!1,$s=!1;const ie=[];let Oe=0;const gt=[];let ze=null,Ge=0;const zo=Promise.resolve();let un=null;function Do(e){const t=un||zo;return e?t.then(this?e.bind(this):e):t}function mi(e){let t=Oe+1,s=ie.length;for(;t<s;){const n=t+s>>>1,o=ie[n],a=Bt(o);a<e||a===e&&o.pre?t=n+1:s=n}return t}function fn(e){(!ie.length||!ie.includes(e,Ht&&e.allowRecurse?Oe+1:Oe))&&(e.id==null?ie.push(e):ie.splice(mi(e.id),0,e),No())}function No(){!Ht&&!$s&&($s=!0,un=zo.then($o))}function hi(e){const t=ie.indexOf(e);t>Oe&&ie.splice(t,1)}function vi(e){D(e)?gt.push(...e):(!ze||!ze.includes(e,e.allowRecurse?Ge+1:Ge))&&gt.push(e),No()}function On(e,t=Ht?Oe+1:0){for(;t<ie.length;t++){const s=ie[t];s&&s.pre&&(ie.splice(t,1),t--,s())}}function Fo(e){if(gt.length){const t=[...new Set(gt)];if(gt.length=0,ze){ze.push(...t);return}for(ze=t,ze.sort((s,n)=>Bt(s)-Bt(n)),Ge=0;Ge<ze.length;Ge++)ze[Ge]();ze=null,Ge=0}}const Bt=e=>e.id==null?1/0:e.id,gi=(e,t)=>{const s=Bt(e)-Bt(t);if(s===0){if(e.pre&&!t.pre)return-1;if(t.pre&&!e.pre)return 1}return s};function $o(e){$s=!1,Ht=!0,ie.sort(gi);try{for(Oe=0;Oe<ie.length;Oe++){const t=ie[Oe];t&&t.active!==!1&&Qe(t,null,14)}}finally{Oe=0,ie.length=0,Fo(),Ht=!1,un=null,(ie.length||gt.length)&&$o()}}function xi(e,t,...s){if(e.isUnmounted)return;const n=e.vnode.props||J;let o=s;const a=t.startsWith("update:"),i=a&&t.slice(7);if(i&&i in n){const u=`${i==="modelValue"?"model":i}Modifiers`,{number:m,trim:h}=n[u]||J;h&&(o=s.map(_=>ne(_)?_.trim():_)),m&&(o=s.map(Oa))}let c,r=n[c=Ps(t)]||n[c=Ps(Me(t))];!r&&a&&(r=n[c=Ps(Et(t))]),r&&_e(r,e,6,o);const f=n[c+"Once"];if(f){if(!e.emitted)e.emitted={};else if(e.emitted[c])return;e.emitted[c]=!0,_e(f,e,6,o)}}function Ho(e,t,s=!1){const n=t.emitsCache,o=n.get(e);if(o!==void 0)return o;const a=e.emits;let i={},c=!1;if(!N(e)){const r=f=>{const u=Ho(f,t,!0);u&&(c=!0,se(i,u))};!s&&t.mixins.length&&t.mixins.forEach(r),e.extends&&r(e.extends),e.mixins&&e.mixins.forEach(r)}return!a&&!c?(Y(e)&&n.set(e,null),null):(D(a)?a.forEach(r=>i[r]=null):se(i,a),Y(e)&&n.set(e,i),i)}function _s(e,t){return!e||!ps(t)?!1:(t=t.slice(2).replace(/Once$/,""),$(e,t[0].toLowerCase()+t.slice(1))||$(e,Et(t))||$(e,t))}let be=null,ws=null;function cs(e){const t=be;return be=e,ws=e&&e.type.__scopeId||null,t}function bi(e){ws=e}function yi(){ws=null}function Mt(e,t=be,s){if(!t||e._n)return e;const n=(...o)=>{n._d&&Hn(-1);const a=cs(t);let i;try{i=e(...o)}finally{cs(a),n._d&&Hn(1)}return i};return n._n=!0,n._c=!0,n._d=!0,n}function As(e){const{type:t,vnode:s,proxy:n,withProxy:o,props:a,propsOptions:[i],slots:c,attrs:r,emit:f,render:u,renderCache:m,data:h,setupState:_,ctx:R,inheritAttrs:S}=e;let z,M;const T=cs(e);try{if(s.shapeFlag&4){const U=o||n;z=Se(u.call(U,U,m,a,_,h,R)),M=r}else{const U=t;z=Se(U.length>1?U(a,{attrs:r,slots:c,emit:f}):U(a,null)),M=t.props?r:_i(r)}}catch(U){Dt.length=0,ys(U,e,1),z=G(kt)}let H=z;if(M&&S!==!1){const U=Object.keys(M),{shapeFlag:oe}=H;U.length&&oe&7&&(i&&U.some(Gs)&&(M=wi(M,i)),H=bt(H,M))}return s.dirs&&(H=bt(H),H.dirs=H.dirs?H.dirs.concat(s.dirs):s.dirs),s.transition&&(H.transition=s.transition),z=H,cs(T),z}const _i=e=>{let t;for(const s in e)(s==="class"||s==="style"||ps(s))&&((t||(t={}))[s]=e[s]);return t},wi=(e,t)=>{const s={};for(const n in e)(!Gs(n)||!(n.slice(9)in t))&&(s[n]=e[n]);return s};function Ei(e,t,s){const{props:n,children:o,component:a}=e,{props:i,children:c,patchFlag:r}=t,f=a.emitsOptions;if(t.dirs||t.transition)return!0;if(s&&r>=0){if(r&1024)return!0;if(r&16)return n?In(n,i,f):!!i;if(r&8){const u=t.dynamicProps;for(let m=0;m<u.length;m++){const h=u[m];if(i[h]!==n[h]&&!_s(f,h))return!0}}}else return(o||c)&&(!c||!c.$stable)?!0:n===i?!1:n?i?In(n,i,f):!0:!!i;return!1}function In(e,t,s){const n=Object.keys(t);if(n.length!==Object.keys(e).length)return!0;for(let o=0;o<n.length;o++){const a=n[o];if(t[a]!==e[a]&&!_s(s,a))return!0}return!1}function ji({vnode:e,parent:t},s){for(;t&&t.subTree===e;)(e=t.vnode).el=s,t=t.parent}const Bo="components";function ko(e,t){return qi(Bo,e,!0,t)||e}const Ci=Symbol.for("v-ndc");function qi(e,t,s=!0,n=!1){const o=be||te;if(o){const a=o.type;if(e===Bo){const c=xr(a,!1);if(c&&(c===t||c===Me(t)||c===gs(Me(t))))return a}const i=Mn(o[e]||a[e],t)||Mn(o.appContext[e],t);return!i&&n?a:i}}function Mn(e,t){return e&&(e[t]||e[Me(t)]||e[gs(Me(t))])}const Pi=e=>e.__isSuspense;function Ri(e,t){t&&t.pendingBranch?D(e)?t.effects.push(...e):t.effects.push(e):vi(e)}const es={};function ss(e,t,s){return Ko(e,t,s)}function Ko(e,t,{immediate:s,deep:n,flush:o,onTrack:a,onTrigger:i}=J){var c;const r=Fa()===((c=te)==null?void 0:c.scope)?te:null;let f,u=!1,m=!1;if(re(e)?(f=()=>e.value,u=ls(e)):ht(e)?(f=()=>e,n=!0):D(e)?(m=!0,u=e.some(U=>ht(U)||ls(U)),f=()=>e.map(U=>{if(re(U))return U.value;if(ht(U))return pt(U);if(N(U))return Qe(U,r,2)})):N(e)?t?f=()=>Qe(e,r,2):f=()=>{if(!(r&&r.isUnmounted))return h&&h(),_e(e,r,3,[_])}:f=Ie,t&&n){const U=f;f=()=>pt(U())}let h,_=U=>{h=T.onStop=()=>{Qe(U,r,4)}},R;if(Wt)if(_=Ie,t?s&&_e(t,r,3,[f(),m?[]:void 0,_]):f(),o==="sync"){const U=_r();R=U.__watcherHandles||(U.__watcherHandles=[])}else return Ie;let S=m?new Array(e.length).fill(es):es;const z=()=>{if(T.active)if(t){const U=T.run();(n||u||(m?U.some((oe,le)=>nt(oe,S[le])):nt(U,S)))&&(h&&h(),_e(t,r,3,[U,S===es?void 0:m&&S[0]===es?[]:S,_]),S=U)}else T.run()};z.allowRecurse=!!t;let M;o==="sync"?M=z:o==="post"?M=()=>fe(z,r&&r.suspense):(z.pre=!0,r&&(z.id=r.uid),M=()=>fn(z));const T=new an(f,M);t?s?z():S=T.run():o==="post"?fe(T.run.bind(T),r&&r.suspense):T.run();const H=()=>{T.stop(),r&&r.scope&&en(r.scope.effects,T)};return R&&R.push(H),H}function Ai(e,t,s){const n=this.proxy,o=ne(e)?e.includes(".")?Wo(n,e):()=>n[e]:e.bind(n,n);let a;N(t)?a=t:(a=t.handler,s=t);const i=te;yt(this);const c=Ko(o,a.bind(n),s);return i?yt(i):st(),c}function Wo(e,t){const s=t.split(".");return()=>{let n=e;for(let o=0;o<s.length&&n;o++)n=n[s[o]];return n}}function pt(e,t){if(!Y(e)||e.__v_skip||(t=t||new Set,t.has(e)))return e;if(t.add(e),re(e))pt(e.value,t);else if(D(e))for(let s=0;s<e.length;s++)pt(e[s],t);else if(Ca(e)||Lt(e))e.forEach(s=>{pt(s,t)});else if(Ra(e))for(const s in e)pt(e[s],t);return e}function Ye(e,t,s,n){const o=e.dirs,a=t&&t.dirs;for(let i=0;i<o.length;i++){const c=o[i];a&&(c.oldValue=a[i].value);let r=c.dir[n];r&&(jt(),_e(r,s,8,[e.el,c,e,t]),Ct())}}/*! #__NO_SIDE_EFFECTS__ */function Vo(e,t){return N(e)?(()=>se({name:e.name},t,{setup:e}))():e}const ns=e=>!!e.type.__asyncLoader,Qo=e=>e.type.__isKeepAlive;function Si(e,t){Xo(e,"a",t)}function Oi(e,t){Xo(e,"da",t)}function Xo(e,t,s=te){const n=e.__wdc||(e.__wdc=()=>{let o=s;for(;o;){if(o.isDeactivated)return;o=o.parent}return e()});if(Es(t,n,s),s){let o=s.parent;for(;o&&o.parent;)Qo(o.parent.vnode)&&Ii(n,t,s,o),o=o.parent}}function Ii(e,t,s,n){const o=Es(t,e,n,!0);Jo(()=>{en(n[t],o)},s)}function Es(e,t,s=te,n=!1){if(s){const o=s[e]||(s[e]=[]),a=t.__weh||(t.__weh=(...i)=>{if(s.isUnmounted)return;jt(),yt(s);const c=_e(t,s,e,i);return st(),Ct(),c});return n?o.unshift(a):o.push(a),a}}const Fe=e=>(t,s=te)=>(!Wt||e==="sp")&&Es(e,(...n)=>t(...n),s),Mi=Fe("bm"),Ti=Fe("m"),Ui=Fe("bu"),Li=Fe("u"),zi=Fe("bum"),Jo=Fe("um"),Di=Fe("sp"),Ni=Fe("rtg"),Fi=Fe("rtc");function $i(e,t=te){Es("ec",e,t)}const Hs=e=>e?ia(e)?gn(e)||e.proxy:Hs(e.parent):null,zt=se(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>Hs(e.parent),$root:e=>Hs(e.root),$emit:e=>e.emit,$options:e=>pn(e),$forceUpdate:e=>e.f||(e.f=()=>fn(e.update)),$nextTick:e=>e.n||(e.n=Do.bind(e.proxy)),$watch:e=>Ai.bind(e)}),Ss=(e,t)=>e!==J&&!e.__isScriptSetup&&$(e,t),Hi={get({_:e},t){const{ctx:s,setupState:n,data:o,props:a,accessCache:i,type:c,appContext:r}=e;let f;if(t[0]!=="$"){const _=i[t];if(_!==void 0)switch(_){case 1:return n[t];case 2:return o[t];case 4:return s[t];case 3:return a[t]}else{if(Ss(n,t))return i[t]=1,n[t];if(o!==J&&$(o,t))return i[t]=2,o[t];if((f=e.propsOptions[0])&&$(f,t))return i[t]=3,a[t];if(s!==J&&$(s,t))return i[t]=4,s[t];Bs&&(i[t]=0)}}const u=zt[t];let m,h;if(u)return t==="$attrs"&&pe(e,"get",t),u(e);if((m=c.__cssModules)&&(m=m[t]))return m;if(s!==J&&$(s,t))return i[t]=4,s[t];if(h=r.config.globalProperties,$(h,t))return h[t]},set({_:e},t,s){const{data:n,setupState:o,ctx:a}=e;return Ss(o,t)?(o[t]=s,!0):n!==J&&$(n,t)?(n[t]=s,!0):$(e.props,t)||t[0]==="$"&&t.slice(1)in e?!1:(a[t]=s,!0)},has({_:{data:e,setupState:t,accessCache:s,ctx:n,appContext:o,propsOptions:a}},i){let c;return!!s[i]||e!==J&&$(e,i)||Ss(t,i)||(c=a[0])&&$(c,i)||$(n,i)||$(zt,i)||$(o.config.globalProperties,i)},defineProperty(e,t,s){return s.get!=null?e._.accessCache[t]=0:$(s,"value")&&this.set(e,t,s.value,null),Reflect.defineProperty(e,t,s)}};function Tn(e){return D(e)?e.reduce((t,s)=>(t[s]=null,t),{}):e}let Bs=!0;function Bi(e){const t=pn(e),s=e.proxy,n=e.ctx;Bs=!1,t.beforeCreate&&Un(t.beforeCreate,e,"bc");const{data:o,computed:a,methods:i,watch:c,provide:r,inject:f,created:u,beforeMount:m,mounted:h,beforeUpdate:_,updated:R,activated:S,deactivated:z,beforeDestroy:M,beforeUnmount:T,destroyed:H,unmounted:U,render:oe,renderTracked:le,renderTriggered:Ee,errorCaptured:Te,serverPrefetch:it,expose:je,inheritAttrs:$e,components:Je,directives:Ce,filters:Rt}=t;if(f&&ki(f,n,null),i)for(const Q in i){const k=i[Q];N(k)&&(n[Q]=k.bind(s))}if(o){const Q=o.call(s,s);Y(Q)&&(e.data=bs(Q))}if(Bs=!0,a)for(const Q in a){const k=a[Q],Ue=N(k)?k.bind(s,s):N(k.get)?k.get.bind(s,s):Ie,He=!N(k)&&N(k.set)?k.set.bind(s):Ie,qe=xe({get:Ue,set:He});Object.defineProperty(n,Q,{enumerable:!0,configurable:!0,get:()=>qe.value,set:ue=>qe.value=ue})}if(c)for(const Q in c)Yo(c[Q],n,s,Q);if(r){const Q=N(r)?r.call(s):r;Reflect.ownKeys(Q).forEach(k=>{os(k,Q[k])})}u&&Un(u,e,"c");function ee(Q,k){D(k)?k.forEach(Ue=>Q(Ue.bind(s))):k&&Q(k.bind(s))}if(ee(Mi,m),ee(Ti,h),ee(Ui,_),ee(Li,R),ee(Si,S),ee(Oi,z),ee($i,Te),ee(Fi,le),ee(Ni,Ee),ee(zi,T),ee(Jo,U),ee(Di,it),D(je))if(je.length){const Q=e.exposed||(e.exposed={});je.forEach(k=>{Object.defineProperty(Q,k,{get:()=>s[k],set:Ue=>s[k]=Ue})})}else e.exposed||(e.exposed={});oe&&e.render===Ie&&(e.render=oe),$e!=null&&(e.inheritAttrs=$e),Je&&(e.components=Je),Ce&&(e.directives=Ce)}function ki(e,t,s=Ie){D(e)&&(e=ks(e));for(const n in e){const o=e[n];let a;Y(o)?"default"in o?a=Ne(o.from||n,o.default,!0):a=Ne(o.from||n):a=Ne(o),re(a)?Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:()=>a.value,set:i=>a.value=i}):t[n]=a}}function Un(e,t,s){_e(D(e)?e.map(n=>n.bind(t.proxy)):e.bind(t.proxy),t,s)}function Yo(e,t,s,n){const o=n.includes(".")?Wo(s,n):()=>s[n];if(ne(e)){const a=t[e];N(a)&&ss(o,a)}else if(N(e))ss(o,e.bind(s));else if(Y(e))if(D(e))e.forEach(a=>Yo(a,t,s,n));else{const a=N(e.handler)?e.handler.bind(s):t[e.handler];N(a)&&ss(o,a,e)}}function pn(e){const t=e.type,{mixins:s,extends:n}=t,{mixins:o,optionsCache:a,config:{optionMergeStrategies:i}}=e.appContext,c=a.get(t);let r;return c?r=c:!o.length&&!s&&!n?r=t:(r={},o.length&&o.forEach(f=>ds(r,f,i,!0)),ds(r,t,i)),Y(t)&&a.set(t,r),r}function ds(e,t,s,n=!1){const{mixins:o,extends:a}=t;a&&ds(e,a,s,!0),o&&o.forEach(i=>ds(e,i,s,!0));for(const i in t)if(!(n&&i==="expose")){const c=Ki[i]||s&&s[i];e[i]=c?c(e[i],t[i]):t[i]}return e}const Ki={data:Ln,props:zn,emits:zn,methods:Tt,computed:Tt,beforeCreate:ce,created:ce,beforeMount:ce,mounted:ce,beforeUpdate:ce,updated:ce,beforeDestroy:ce,beforeUnmount:ce,destroyed:ce,unmounted:ce,activated:ce,deactivated:ce,errorCaptured:ce,serverPrefetch:ce,components:Tt,directives:Tt,watch:Vi,provide:Ln,inject:Wi};function Ln(e,t){return t?e?function(){return se(N(e)?e.call(this,this):e,N(t)?t.call(this,this):t)}:t:e}function Wi(e,t){return Tt(ks(e),ks(t))}function ks(e){if(D(e)){const t={};for(let s=0;s<e.length;s++)t[e[s]]=e[s];return t}return e}function ce(e,t){return e?[...new Set([].concat(e,t))]:t}function Tt(e,t){return e?se(Object.create(null),e,t):t}function zn(e,t){return e?D(e)&&D(t)?[...new Set([...e,...t])]:se(Object.create(null),Tn(e),Tn(t??{})):t}function Vi(e,t){if(!e)return t;if(!t)return e;const s=se(Object.create(null),e);for(const n in t)s[n]=ce(e[n],t[n]);return s}function Zo(){return{app:null,config:{isNativeTag:wa,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let Qi=0;function Xi(e,t){return function(n,o=null){N(n)||(n=se({},n)),o!=null&&!Y(o)&&(o=null);const a=Zo(),i=new WeakSet;let c=!1;const r=a.app={_uid:Qi++,_component:n,_props:o,_container:null,_context:a,_instance:null,version:wr,get config(){return a.config},set config(f){},use(f,...u){return i.has(f)||(f&&N(f.install)?(i.add(f),f.install(r,...u)):N(f)&&(i.add(f),f(r,...u))),r},mixin(f){return a.mixins.includes(f)||a.mixins.push(f),r},component(f,u){return u?(a.components[f]=u,r):a.components[f]},directive(f,u){return u?(a.directives[f]=u,r):a.directives[f]},mount(f,u,m){if(!c){const h=G(n,o);return h.appContext=a,u&&t?t(h,f):e(h,f,m),c=!0,r._container=f,f.__vue_app__=r,gn(h.component)||h.component.proxy}},unmount(){c&&(e(null,r._container),delete r._container.__vue_app__)},provide(f,u){return a.provides[f]=u,r},runWithContext(f){us=r;try{return f()}finally{us=null}}};return r}}let us=null;function os(e,t){if(te){let s=te.provides;const n=te.parent&&te.parent.provides;n===s&&(s=te.provides=Object.create(n)),s[e]=t}}function Ne(e,t,s=!1){const n=te||be;if(n||us){const o=n?n.parent==null?n.vnode.appContext&&n.vnode.appContext.provides:n.parent.provides:us._context.provides;if(o&&e in o)return o[e];if(arguments.length>1)return s&&N(t)?t.call(n&&n.proxy):t}}function Ji(e,t,s,n=!1){const o={},a={};rs(a,Cs,1),e.propsDefaults=Object.create(null),Go(e,t,o,a);for(const i in e.propsOptions[0])i in o||(o[i]=void 0);s?e.props=n?o:Ao(o):e.type.props?e.props=o:e.props=a,e.attrs=a}function Yi(e,t,s,n){const{props:o,attrs:a,vnode:{patchFlag:i}}=e,c=B(o),[r]=e.propsOptions;let f=!1;if((n||i>0)&&!(i&16)){if(i&8){const u=e.vnode.dynamicProps;for(let m=0;m<u.length;m++){let h=u[m];if(_s(e.emitsOptions,h))continue;const _=t[h];if(r)if($(a,h))_!==a[h]&&(a[h]=_,f=!0);else{const R=Me(h);o[R]=Ks(r,c,R,_,e,!1)}else _!==a[h]&&(a[h]=_,f=!0)}}}else{Go(e,t,o,a)&&(f=!0);let u;for(const m in c)(!t||!$(t,m)&&((u=Et(m))===m||!$(t,u)))&&(r?s&&(s[m]!==void 0||s[u]!==void 0)&&(o[m]=Ks(r,c,m,void 0,e,!0)):delete o[m]);if(a!==c)for(const m in a)(!t||!$(t,m))&&(delete a[m],f=!0)}f&&De(e,"set","$attrs")}function Go(e,t,s,n){const[o,a]=e.propsOptions;let i=!1,c;if(t)for(let r in t){if(ts(r))continue;const f=t[r];let u;o&&$(o,u=Me(r))?!a||!a.includes(u)?s[u]=f:(c||(c={}))[u]=f:_s(e.emitsOptions,r)||(!(r in n)||f!==n[r])&&(n[r]=f,i=!0)}if(a){const r=B(s),f=c||J;for(let u=0;u<a.length;u++){const m=a[u];s[m]=Ks(o,r,m,f[m],e,!$(f,m))}}return i}function Ks(e,t,s,n,o,a){const i=e[s];if(i!=null){const c=$(i,"default");if(c&&n===void 0){const r=i.default;if(i.type!==Function&&!i.skipFactory&&N(r)){const{propsDefaults:f}=o;s in f?n=f[s]:(yt(o),n=f[s]=r.call(null,t),st())}else n=r}i[0]&&(a&&!c?n=!1:i[1]&&(n===""||n===Et(s))&&(n=!0))}return n}function ea(e,t,s=!1){const n=t.propsCache,o=n.get(e);if(o)return o;const a=e.props,i={},c=[];let r=!1;if(!N(e)){const u=m=>{r=!0;const[h,_]=ea(m,t,!0);se(i,h),_&&c.push(..._)};!s&&t.mixins.length&&t.mixins.forEach(u),e.extends&&u(e.extends),e.mixins&&e.mixins.forEach(u)}if(!a&&!r)return Y(e)&&n.set(e,mt),mt;if(D(a))for(let u=0;u<a.length;u++){const m=Me(a[u]);Dn(m)&&(i[m]=J)}else if(a)for(const u in a){const m=Me(u);if(Dn(m)){const h=a[u],_=i[m]=D(h)||N(h)?{type:h}:se({},h);if(_){const R=$n(Boolean,_.type),S=$n(String,_.type);_[0]=R>-1,_[1]=S<0||R<S,(R>-1||$(_,"default"))&&c.push(m)}}}const f=[i,c];return Y(e)&&n.set(e,f),f}function Dn(e){return e[0]!=="$"}function Nn(e){const t=e&&e.toString().match(/^\s*(function|class) (\w+)/);return t?t[2]:e===null?"null":""}function Fn(e,t){return Nn(e)===Nn(t)}function $n(e,t){return D(t)?t.findIndex(s=>Fn(s,e)):N(t)&&Fn(t,e)?0:-1}const ta=e=>e[0]==="_"||e==="$stable",mn=e=>D(e)?e.map(Se):[Se(e)],Zi=(e,t,s)=>{if(t._n)return t;const n=Mt((...o)=>mn(t(...o)),s);return n._c=!1,n},sa=(e,t,s)=>{const n=e._ctx;for(const o in e){if(ta(o))continue;const a=e[o];if(N(a))t[o]=Zi(o,a,n);else if(a!=null){const i=mn(a);t[o]=()=>i}}},na=(e,t)=>{const s=mn(t);e.slots.default=()=>s},Gi=(e,t)=>{if(e.vnode.shapeFlag&32){const s=t._;s?(e.slots=B(t),rs(t,"_",s)):sa(t,e.slots={})}else e.slots={},t&&na(e,t);rs(e.slots,Cs,1)},er=(e,t,s)=>{const{vnode:n,slots:o}=e;let a=!0,i=J;if(n.shapeFlag&32){const c=t._;c?s&&c===1?a=!1:(se(o,t),!s&&c===1&&delete o._):(a=!t.$stable,sa(t,o)),i=t}else t&&(na(e,t),i={default:1});if(a)for(const c in o)!ta(c)&&i[c]==null&&delete o[c]};function Ws(e,t,s,n,o=!1){if(D(e)){e.forEach((h,_)=>Ws(h,t&&(D(t)?t[_]:t),s,n,o));return}if(ns(n)&&!o)return;const a=n.shapeFlag&4?gn(n.component)||n.component.proxy:n.el,i=o?null:a,{i:c,r}=e,f=t&&t.r,u=c.refs===J?c.refs={}:c.refs,m=c.setupState;if(f!=null&&f!==r&&(ne(f)?(u[f]=null,$(m,f)&&(m[f]=null)):re(f)&&(f.value=null)),N(r))Qe(r,c,12,[i,u]);else{const h=ne(r),_=re(r);if(h||_){const R=()=>{if(e.f){const S=h?$(m,r)?m[r]:u[r]:r.value;o?D(S)&&en(S,a):D(S)?S.includes(a)||S.push(a):h?(u[r]=[a],$(m,r)&&(m[r]=u[r])):(r.value=[a],e.k&&(u[e.k]=r.value))}else h?(u[r]=i,$(m,r)&&(m[r]=i)):_&&(r.value=i,e.k&&(u[e.k]=i))};i?(R.id=-1,fe(R,s)):R()}}}const fe=Ri;function tr(e){return sr(e)}function sr(e,t){const s=Ls();s.__VUE__=!0;const{insert:n,remove:o,patchProp:a,createElement:i,createText:c,createComment:r,setText:f,setElementText:u,parentNode:m,nextSibling:h,setScopeId:_=Ie,insertStaticContent:R}=e,S=(l,d,p,v=null,x=null,b=null,C=!1,w=null,E=!!d.dynamicChildren)=>{if(l===d)return;l&&!St(l,d)&&(v=g(l),ue(l,x,b,!0),l=null),d.patchFlag===-2&&(E=!1,d.dynamicChildren=null);const{type:y,ref:O,shapeFlag:P}=d;switch(y){case js:z(l,d,p,v);break;case kt:M(l,d,p,v);break;case as:l==null&&T(d,p,v,C);break;case Ae:Je(l,d,p,v,x,b,C,w,E);break;default:P&1?oe(l,d,p,v,x,b,C,w,E):P&6?Ce(l,d,p,v,x,b,C,w,E):(P&64||P&128)&&y.process(l,d,p,v,x,b,C,w,E,j)}O!=null&&x&&Ws(O,l&&l.ref,b,d||l,!d)},z=(l,d,p,v)=>{if(l==null)n(d.el=c(d.children),p,v);else{const x=d.el=l.el;d.children!==l.children&&f(x,d.children)}},M=(l,d,p,v)=>{l==null?n(d.el=r(d.children||""),p,v):d.el=l.el},T=(l,d,p,v)=>{[l.el,l.anchor]=R(l.children,d,p,v,l.el,l.anchor)},H=({el:l,anchor:d},p,v)=>{let x;for(;l&&l!==d;)x=h(l),n(l,p,v),l=x;n(d,p,v)},U=({el:l,anchor:d})=>{let p;for(;l&&l!==d;)p=h(l),o(l),l=p;o(d)},oe=(l,d,p,v,x,b,C,w,E)=>{C=C||d.type==="svg",l==null?le(d,p,v,x,b,C,w,E):it(l,d,x,b,C,w,E)},le=(l,d,p,v,x,b,C,w)=>{let E,y;const{type:O,props:P,shapeFlag:I,transition:L,dirs:F}=l;if(E=l.el=i(l.type,b,P&&P.is,P),I&8?u(E,l.children):I&16&&Te(l.children,E,null,v,x,b&&O!=="foreignObject",C,w),F&&Ye(l,null,v,"created"),Ee(E,l,l.scopeId,C,v),P){for(const V in P)V!=="value"&&!ts(V)&&a(E,V,null,P[V],b,l.children,v,x,ae);"value"in P&&a(E,"value",null,P.value),(y=P.onVnodeBeforeMount)&&Re(y,v,l)}F&&Ye(l,null,v,"beforeMount");const X=nr(x,L);X&&L.beforeEnter(E),n(E,d,p),((y=P&&P.onVnodeMounted)||X||F)&&fe(()=>{y&&Re(y,v,l),X&&L.enter(E),F&&Ye(l,null,v,"mounted")},x)},Ee=(l,d,p,v,x)=>{if(p&&_(l,p),v)for(let b=0;b<v.length;b++)_(l,v[b]);if(x){let b=x.subTree;if(d===b){const C=x.vnode;Ee(l,C,C.scopeId,C.slotScopeIds,x.parent)}}},Te=(l,d,p,v,x,b,C,w,E=0)=>{for(let y=E;y<l.length;y++){const O=l[y]=w?Ke(l[y]):Se(l[y]);S(null,O,d,p,v,x,b,C,w)}},it=(l,d,p,v,x,b,C)=>{const w=d.el=l.el;let{patchFlag:E,dynamicChildren:y,dirs:O}=d;E|=l.patchFlag&16;const P=l.props||J,I=d.props||J;let L;p&&Ze(p,!1),(L=I.onVnodeBeforeUpdate)&&Re(L,p,d,l),O&&Ye(d,l,p,"beforeUpdate"),p&&Ze(p,!0);const F=x&&d.type!=="foreignObject";if(y?je(l.dynamicChildren,y,w,p,v,F,b):C||k(l,d,w,null,p,v,F,b,!1),E>0){if(E&16)$e(w,d,P,I,p,v,x);else if(E&2&&P.class!==I.class&&a(w,"class",null,I.class,x),E&4&&a(w,"style",P.style,I.style,x),E&8){const X=d.dynamicProps;for(let V=0;V<X.length;V++){const Z=X[V],he=P[Z],dt=I[Z];(dt!==he||Z==="value")&&a(w,Z,he,dt,x,l.children,p,v,ae)}}E&1&&l.children!==d.children&&u(w,d.children)}else!C&&y==null&&$e(w,d,P,I,p,v,x);((L=I.onVnodeUpdated)||O)&&fe(()=>{L&&Re(L,p,d,l),O&&Ye(d,l,p,"updated")},v)},je=(l,d,p,v,x,b,C)=>{for(let w=0;w<d.length;w++){const E=l[w],y=d[w],O=E.el&&(E.type===Ae||!St(E,y)||E.shapeFlag&70)?m(E.el):p;S(E,y,O,null,v,x,b,C,!0)}},$e=(l,d,p,v,x,b,C)=>{if(p!==v){if(p!==J)for(const w in p)!ts(w)&&!(w in v)&&a(l,w,p[w],null,C,d.children,x,b,ae);for(const w in v){if(ts(w))continue;const E=v[w],y=p[w];E!==y&&w!=="value"&&a(l,w,y,E,C,d.children,x,b,ae)}"value"in v&&a(l,"value",p.value,v.value)}},Je=(l,d,p,v,x,b,C,w,E)=>{const y=d.el=l?l.el:c(""),O=d.anchor=l?l.anchor:c("");let{patchFlag:P,dynamicChildren:I,slotScopeIds:L}=d;L&&(w=w?w.concat(L):L),l==null?(n(y,p,v),n(O,p,v),Te(d.children,p,O,x,b,C,w,E)):P>0&&P&64&&I&&l.dynamicChildren?(je(l.dynamicChildren,I,p,x,b,C,w),(d.key!=null||x&&d===x.subTree)&&oa(l,d,!0)):k(l,d,p,O,x,b,C,w,E)},Ce=(l,d,p,v,x,b,C,w,E)=>{d.slotScopeIds=w,l==null?d.shapeFlag&512?x.ctx.activate(d,p,v,C,E):Rt(d,p,v,x,b,C,E):rt(l,d,E)},Rt=(l,d,p,v,x,b,C)=>{const w=l.component=pr(l,v,x);if(Qo(l)&&(w.ctx.renderer=j),mr(w),w.asyncDep){if(x&&x.registerDep(w,ee),!l.el){const E=w.subTree=G(kt);M(null,E,d,p)}return}ee(w,l,d,p,x,b,C)},rt=(l,d,p)=>{const v=d.component=l.component;if(Ei(l,d,p))if(v.asyncDep&&!v.asyncResolved){Q(v,d,p);return}else v.next=d,hi(v.update),v.update();else d.el=l.el,v.vnode=d},ee=(l,d,p,v,x,b,C)=>{const w=()=>{if(l.isMounted){let{next:O,bu:P,u:I,parent:L,vnode:F}=l,X=O,V;Ze(l,!1),O?(O.el=F.el,Q(l,O,C)):O=F,P&&Rs(P),(V=O.props&&O.props.onVnodeBeforeUpdate)&&Re(V,L,O,F),Ze(l,!0);const Z=As(l),he=l.subTree;l.subTree=Z,S(he,Z,m(he.el),g(he),l,x,b),O.el=Z.el,X===null&&ji(l,Z.el),I&&fe(I,x),(V=O.props&&O.props.onVnodeUpdated)&&fe(()=>Re(V,L,O,F),x)}else{let O;const{el:P,props:I}=d,{bm:L,m:F,parent:X}=l,V=ns(d);if(Ze(l,!1),L&&Rs(L),!V&&(O=I&&I.onVnodeBeforeMount)&&Re(O,X,d),Ze(l,!0),P&&K){const Z=()=>{l.subTree=As(l),K(P,l.subTree,l,x,null)};V?d.type.__asyncLoader().then(()=>!l.isUnmounted&&Z()):Z()}else{const Z=l.subTree=As(l);S(null,Z,p,v,l,x,b),d.el=Z.el}if(F&&fe(F,x),!V&&(O=I&&I.onVnodeMounted)){const Z=d;fe(()=>Re(O,X,Z),x)}(d.shapeFlag&256||X&&ns(X.vnode)&&X.vnode.shapeFlag&256)&&l.a&&fe(l.a,x),l.isMounted=!0,d=p=v=null}},E=l.effect=new an(w,()=>fn(y),l.scope),y=l.update=()=>E.run();y.id=l.uid,Ze(l,!0),y()},Q=(l,d,p)=>{d.component=l;const v=l.vnode.props;l.vnode=d,l.next=null,Yi(l,d.props,v,p),er(l,d.children,p),jt(),On(),Ct()},k=(l,d,p,v,x,b,C,w,E=!1)=>{const y=l&&l.children,O=l?l.shapeFlag:0,P=d.children,{patchFlag:I,shapeFlag:L}=d;if(I>0){if(I&128){He(y,P,p,v,x,b,C,w,E);return}else if(I&256){Ue(y,P,p,v,x,b,C,w,E);return}}L&8?(O&16&&ae(y,x,b),P!==y&&u(p,P)):O&16?L&16?He(y,P,p,v,x,b,C,w,E):ae(y,x,b,!0):(O&8&&u(p,""),L&16&&Te(P,p,v,x,b,C,w,E))},Ue=(l,d,p,v,x,b,C,w,E)=>{l=l||mt,d=d||mt;const y=l.length,O=d.length,P=Math.min(y,O);let I;for(I=0;I<P;I++){const L=d[I]=E?Ke(d[I]):Se(d[I]);S(l[I],L,p,null,x,b,C,w,E)}y>O?ae(l,x,b,!0,!1,P):Te(d,p,v,x,b,C,w,E,P)},He=(l,d,p,v,x,b,C,w,E)=>{let y=0;const O=d.length;let P=l.length-1,I=O-1;for(;y<=P&&y<=I;){const L=l[y],F=d[y]=E?Ke(d[y]):Se(d[y]);if(St(L,F))S(L,F,p,null,x,b,C,w,E);else break;y++}for(;y<=P&&y<=I;){const L=l[P],F=d[I]=E?Ke(d[I]):Se(d[I]);if(St(L,F))S(L,F,p,null,x,b,C,w,E);else break;P--,I--}if(y>P){if(y<=I){const L=I+1,F=L<O?d[L].el:v;for(;y<=I;)S(null,d[y]=E?Ke(d[y]):Se(d[y]),p,F,x,b,C,w,E),y++}}else if(y>I)for(;y<=P;)ue(l[y],x,b,!0),y++;else{const L=y,F=y,X=new Map;for(y=F;y<=I;y++){const me=d[y]=E?Ke(d[y]):Se(d[y]);me.key!=null&&X.set(me.key,y)}let V,Z=0;const he=I-F+1;let dt=!1,yn=0;const At=new Array(he);for(y=0;y<he;y++)At[y]=0;for(y=L;y<=P;y++){const me=l[y];if(Z>=he){ue(me,x,b,!0);continue}let Pe;if(me.key!=null)Pe=X.get(me.key);else for(V=F;V<=I;V++)if(At[V-F]===0&&St(me,d[V])){Pe=V;break}Pe===void 0?ue(me,x,b,!0):(At[Pe-F]=y+1,Pe>=yn?yn=Pe:dt=!0,S(me,d[Pe],p,null,x,b,C,w,E),Z++)}const _n=dt?or(At):mt;for(V=_n.length-1,y=he-1;y>=0;y--){const me=F+y,Pe=d[me],wn=me+1<O?d[me+1].el:v;At[y]===0?S(null,Pe,p,wn,x,b,C,w,E):dt&&(V<0||y!==_n[V]?qe(Pe,p,wn,2):V--)}}},qe=(l,d,p,v,x=null)=>{const{el:b,type:C,transition:w,children:E,shapeFlag:y}=l;if(y&6){qe(l.component.subTree,d,p,v);return}if(y&128){l.suspense.move(d,p,v);return}if(y&64){C.move(l,d,p,j);return}if(C===Ae){n(b,d,p);for(let P=0;P<E.length;P++)qe(E[P],d,p,v);n(l.anchor,d,p);return}if(C===as){H(l,d,p);return}if(v!==2&&y&1&&w)if(v===0)w.beforeEnter(b),n(b,d,p),fe(()=>w.enter(b),x);else{const{leave:P,delayLeave:I,afterLeave:L}=w,F=()=>n(b,d,p),X=()=>{P(b,()=>{F(),L&&L()})};I?I(b,F,X):X()}else n(b,d,p)},ue=(l,d,p,v=!1,x=!1)=>{const{type:b,props:C,ref:w,children:E,dynamicChildren:y,shapeFlag:O,patchFlag:P,dirs:I}=l;if(w!=null&&Ws(w,null,p,l,!0),O&256){d.ctx.deactivate(l);return}const L=O&1&&I,F=!ns(l);let X;if(F&&(X=C&&C.onVnodeBeforeUnmount)&&Re(X,d,l),O&6)Qt(l.component,p,v);else{if(O&128){l.suspense.unmount(p,v);return}L&&Ye(l,null,d,"beforeUnmount"),O&64?l.type.remove(l,d,p,x,j,v):y&&(b!==Ae||P>0&&P&64)?ae(y,d,p,!1,!0):(b===Ae&&P&384||!x&&O&16)&&ae(E,d,p),v&&lt(l)}(F&&(X=C&&C.onVnodeUnmounted)||L)&&fe(()=>{X&&Re(X,d,l),L&&Ye(l,null,d,"unmounted")},p)},lt=l=>{const{type:d,el:p,anchor:v,transition:x}=l;if(d===Ae){ct(p,v);return}if(d===as){U(l);return}const b=()=>{o(p),x&&!x.persisted&&x.afterLeave&&x.afterLeave()};if(l.shapeFlag&1&&x&&!x.persisted){const{leave:C,delayLeave:w}=x,E=()=>C(p,b);w?w(l.el,b,E):E()}else b()},ct=(l,d)=>{let p;for(;l!==d;)p=h(l),o(l),l=p;o(d)},Qt=(l,d,p)=>{const{bum:v,scope:x,update:b,subTree:C,um:w}=l;v&&Rs(v),x.stop(),b&&(b.active=!1,ue(C,l,d,p)),w&&fe(w,d),fe(()=>{l.isUnmounted=!0},d),d&&d.pendingBranch&&!d.isUnmounted&&l.asyncDep&&!l.asyncResolved&&l.suspenseId===d.pendingId&&(d.deps--,d.deps===0&&d.resolve())},ae=(l,d,p,v=!1,x=!1,b=0)=>{for(let C=b;C<l.length;C++)ue(l[C],d,p,v,x)},g=l=>l.shapeFlag&6?g(l.component.subTree):l.shapeFlag&128?l.suspense.next():h(l.anchor||l.el),q=(l,d,p)=>{l==null?d._vnode&&ue(d._vnode,null,null,!0):S(d._vnode||null,l,d,null,null,null,p),On(),Fo(),d._vnode=l},j={p:S,um:ue,m:qe,r:lt,mt:Rt,mc:Te,pc:k,pbc:je,n:g,o:e};let A,K;return t&&([A,K]=t(j)),{render:q,hydrate:A,createApp:Xi(q,A)}}function Ze({effect:e,update:t},s){e.allowRecurse=t.allowRecurse=s}function nr(e,t){return(!e||e&&!e.pendingBranch)&&t&&!t.persisted}function oa(e,t,s=!1){const n=e.children,o=t.children;if(D(n)&&D(o))for(let a=0;a<n.length;a++){const i=n[a];let c=o[a];c.shapeFlag&1&&!c.dynamicChildren&&((c.patchFlag<=0||c.patchFlag===32)&&(c=o[a]=Ke(o[a]),c.el=i.el),s||oa(i,c)),c.type===js&&(c.el=i.el)}}function or(e){const t=e.slice(),s=[0];let n,o,a,i,c;const r=e.length;for(n=0;n<r;n++){const f=e[n];if(f!==0){if(o=s[s.length-1],e[o]<f){t[n]=o,s.push(n);continue}for(a=0,i=s.length-1;a<i;)c=a+i>>1,e[s[c]]<f?a=c+1:i=c;f<e[s[a]]&&(a>0&&(t[n]=s[a-1]),s[a]=n)}}for(a=s.length,i=s[a-1];a-- >0;)s[a]=i,i=t[i];return s}const ar=e=>e.__isTeleport,Ae=Symbol.for("v-fgt"),js=Symbol.for("v-txt"),kt=Symbol.for("v-cmt"),as=Symbol.for("v-stc"),Dt=[];let ye=null;function ot(e=!1){Dt.push(ye=e?null:[])}function ir(){Dt.pop(),ye=Dt[Dt.length-1]||null}let Kt=1;function Hn(e){Kt+=e}function rr(e){return e.dynamicChildren=Kt>0?ye||mt:null,ir(),Kt>0&&ye&&ye.push(e),e}function at(e,t,s,n,o,a){return rr(de(e,t,s,n,o,a,!0))}function Vs(e){return e?e.__v_isVNode===!0:!1}function St(e,t){return e.type===t.type&&e.key===t.key}const Cs="__vInternal",aa=({key:e})=>e??null,is=({ref:e,ref_key:t,ref_for:s})=>(typeof e=="number"&&(e=""+e),e!=null?ne(e)||re(e)||N(e)?{i:be,r:e,k:t,f:!!s}:e:null);function de(e,t=null,s=null,n=0,o=null,a=e===Ae?0:1,i=!1,c=!1){const r={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&aa(t),ref:t&&is(t),scopeId:ws,slotScopeIds:null,children:s,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:a,patchFlag:n,dynamicProps:o,dynamicChildren:null,appContext:null,ctx:be};return c?(hn(r,s),a&128&&e.normalize(r)):s&&(r.shapeFlag|=ne(s)?8:16),Kt>0&&!i&&ye&&(r.patchFlag>0||a&6)&&r.patchFlag!==32&&ye.push(r),r}const G=lr;function lr(e,t=null,s=null,n=0,o=null,a=!1){if((!e||e===Ci)&&(e=kt),Vs(e)){const c=bt(e,t,!0);return s&&hn(c,s),Kt>0&&!a&&ye&&(c.shapeFlag&6?ye[ye.indexOf(e)]=c:ye.push(c)),c.patchFlag|=-2,c}if(br(e)&&(e=e.__vccOpts),t){t=cr(t);let{class:c,style:r}=t;c&&!ne(c)&&(t.class=nn(c)),Y(r)&&(Oo(r)&&!D(r)&&(r=se({},r)),t.style=sn(r))}const i=ne(e)?1:Pi(e)?128:ar(e)?64:Y(e)?4:N(e)?2:0;return de(e,t,s,n,o,i,a,!0)}function cr(e){return e?Oo(e)||Cs in e?se({},e):e:null}function bt(e,t,s=!1){const{props:n,ref:o,patchFlag:a,children:i}=e,c=t?dr(n||{},t):n;return{__v_isVNode:!0,__v_skip:!0,type:e.type,props:c,key:c&&aa(c),ref:t&&t.ref?s&&o?D(o)?o.concat(is(t)):[o,is(t)]:is(t):o,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:i,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==Ae?a===-1?16:a|16:a,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&bt(e.ssContent),ssFallback:e.ssFallback&&bt(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce}}function Ut(e=" ",t=0){return G(js,null,e,t)}function qt(e,t){const s=G(as,null,e);return s.staticCount=t,s}function Se(e){return e==null||typeof e=="boolean"?G(kt):D(e)?G(Ae,null,e.slice()):typeof e=="object"?Ke(e):G(js,null,String(e))}function Ke(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:bt(e)}function hn(e,t){let s=0;const{shapeFlag:n}=e;if(t==null)t=null;else if(D(t))s=16;else if(typeof t=="object")if(n&65){const o=t.default;o&&(o._c&&(o._d=!1),hn(e,o()),o._c&&(o._d=!0));return}else{s=32;const o=t._;!o&&!(Cs in t)?t._ctx=be:o===3&&be&&(be.slots._===1?t._=1:(t._=2,e.patchFlag|=1024))}else N(t)?(t={default:t,_ctx:be},s=32):(t=String(t),n&64?(s=16,t=[Ut(t)]):s=8);e.children=t,e.shapeFlag|=s}function dr(...e){const t={};for(let s=0;s<e.length;s++){const n=e[s];for(const o in n)if(o==="class")t.class!==n.class&&(t.class=nn([t.class,n.class]));else if(o==="style")t.style=sn([t.style,n.style]);else if(ps(o)){const a=t[o],i=n[o];i&&a!==i&&!(D(a)&&a.includes(i))&&(t[o]=a?[].concat(a,i):i)}else o!==""&&(t[o]=n[o])}return t}function Re(e,t,s,n=null){_e(e,t,7,[s,n])}const ur=Zo();let fr=0;function pr(e,t,s){const n=e.type,o=(t?t.appContext:e.appContext)||ur,a={uid:fr++,vnode:e,type:n,parent:t,appContext:o,root:null,next:null,subTree:null,effect:null,update:null,scope:new Da(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(o.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:ea(n,o),emitsOptions:Ho(n,o),emit:null,emitted:null,propsDefaults:J,inheritAttrs:n.inheritAttrs,ctx:J,data:J,props:J,attrs:J,slots:J,refs:J,setupState:J,setupContext:null,attrsProxy:null,slotsProxy:null,suspense:s,suspenseId:s?s.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return a.ctx={_:a},a.root=t?t.root:a,a.emit=xi.bind(null,a),e.ce&&e.ce(a),a}let te=null,vn,ut,Bn="__VUE_INSTANCE_SETTERS__";(ut=Ls()[Bn])||(ut=Ls()[Bn]=[]),ut.push(e=>te=e),vn=e=>{ut.length>1?ut.forEach(t=>t(e)):ut[0](e)};const yt=e=>{vn(e),e.scope.on()},st=()=>{te&&te.scope.off(),vn(null)};function ia(e){return e.vnode.shapeFlag&4}let Wt=!1;function mr(e,t=!1){Wt=t;const{props:s,children:n}=e.vnode,o=ia(e);Ji(e,s,o,t),Gi(e,n);const a=o?hr(e,t):void 0;return Wt=!1,a}function hr(e,t){const s=e.type;e.accessCache=Object.create(null),e.proxy=Io(new Proxy(e.ctx,Hi));const{setup:n}=s;if(n){const o=e.setupContext=n.length>1?gr(e):null;yt(e),jt();const a=Qe(n,e,0,[e.props,o]);if(Ct(),st(),go(a)){if(a.then(st,st),t)return a.then(i=>{kn(e,i,t)}).catch(i=>{ys(i,e,0)});e.asyncDep=a}else kn(e,a,t)}else ra(e,t)}function kn(e,t,s){N(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:Y(t)&&(e.setupState=Lo(t)),ra(e,s)}let Kn;function ra(e,t,s){const n=e.type;if(!e.render){if(!t&&Kn&&!n.render){const o=n.template||pn(e).template;if(o){const{isCustomElement:a,compilerOptions:i}=e.appContext.config,{delimiters:c,compilerOptions:r}=n,f=se(se({isCustomElement:a,delimiters:c},i),r);n.render=Kn(o,f)}}e.render=n.render||Ie}{yt(e),jt();try{Bi(e)}finally{Ct(),st()}}}function vr(e){return e.attrsProxy||(e.attrsProxy=new Proxy(e.attrs,{get(t,s){return pe(e,"get","$attrs"),t[s]}}))}function gr(e){const t=s=>{e.exposed=s||{}};return{get attrs(){return vr(e)},slots:e.slots,emit:e.emit,expose:t}}function gn(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy(Lo(Io(e.exposed)),{get(t,s){if(s in t)return t[s];if(s in zt)return zt[s](e)},has(t,s){return s in t||s in zt}}))}function xr(e,t=!0){return N(e)?e.displayName||e.name:e.name||t&&e.__name}function br(e){return N(e)&&"__vccOpts"in e}const xe=(e,t)=>fi(e,t,Wt);function la(e,t,s){const n=arguments.length;return n===2?Y(t)&&!D(t)?Vs(t)?G(e,null,[t]):G(e,t):G(e,null,t):(n>3?s=Array.prototype.slice.call(arguments,2):n===3&&Vs(s)&&(s=[s]),G(e,t,s))}const yr=Symbol.for("v-scx"),_r=()=>Ne(yr),wr="3.3.8",Er="http://www.w3.org/2000/svg",et=typeof document<"u"?document:null,Wn=et&&et.createElement("template"),jr={insert:(e,t,s)=>{t.insertBefore(e,s||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,s,n)=>{const o=t?et.createElementNS(Er,e):et.createElement(e,s?{is:s}:void 0);return e==="select"&&n&&n.multiple!=null&&o.setAttribute("multiple",n.multiple),o},createText:e=>et.createTextNode(e),createComment:e=>et.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>et.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,s,n,o,a){const i=s?s.previousSibling:t.lastChild;if(o&&(o===a||o.nextSibling))for(;t.insertBefore(o.cloneNode(!0),s),!(o===a||!(o=o.nextSibling)););else{Wn.innerHTML=n?`<svg>${e}</svg>`:e;const c=Wn.content;if(n){const r=c.firstChild;for(;r.firstChild;)c.appendChild(r.firstChild);c.removeChild(r)}t.insertBefore(c,s)}return[i?i.nextSibling:t.firstChild,s?s.previousSibling:t.lastChild]}},Cr=Symbol("_vtc");function qr(e,t,s){const n=e[Cr];n&&(t=(t?[t,...n]:[...n]).join(" ")),t==null?e.removeAttribute("class"):s?e.setAttribute("class",t):e.className=t}const Pr=Symbol("_vod");function Rr(e,t,s){const n=e.style,o=ne(s);if(s&&!o){if(t&&!ne(t))for(const a in t)s[a]==null&&Qs(n,a,"");for(const a in s)Qs(n,a,s[a])}else{const a=n.display;o?t!==s&&(n.cssText=s):t&&e.removeAttribute("style"),Pr in e&&(n.display=a)}}const Vn=/\s*!important$/;function Qs(e,t,s){if(D(s))s.forEach(n=>Qs(e,t,n));else if(s==null&&(s=""),t.startsWith("--"))e.setProperty(t,s);else{const n=Ar(e,t);Vn.test(s)?e.setProperty(Et(n),s.replace(Vn,""),"important"):e[n]=s}}const Qn=["Webkit","Moz","ms"],Os={};function Ar(e,t){const s=Os[t];if(s)return s;let n=Me(t);if(n!=="filter"&&n in e)return Os[t]=n;n=gs(n);for(let o=0;o<Qn.length;o++){const a=Qn[o]+n;if(a in e)return Os[t]=a}return t}const Xn="http://www.w3.org/1999/xlink";function Sr(e,t,s,n,o){if(n&&t.startsWith("xlink:"))s==null?e.removeAttributeNS(Xn,t.slice(6,t.length)):e.setAttributeNS(Xn,t,s);else{const a=za(t);s==null||a&&!xo(s)?e.removeAttribute(t):e.setAttribute(t,a?"":s)}}function Or(e,t,s,n,o,a,i){if(t==="innerHTML"||t==="textContent"){n&&i(n,o,a),e[t]=s??"";return}const c=e.tagName;if(t==="value"&&c!=="PROGRESS"&&!c.includes("-")){e._value=s;const f=c==="OPTION"?e.getAttribute("value"):e.value,u=s??"";f!==u&&(e.value=u),s==null&&e.removeAttribute(t);return}let r=!1;if(s===""||s==null){const f=typeof e[t];f==="boolean"?s=xo(s):s==null&&f==="string"?(s="",r=!0):f==="number"&&(s=0,r=!0)}try{e[t]=s}catch{}r&&e.removeAttribute(t)}function Ir(e,t,s,n){e.addEventListener(t,s,n)}function Mr(e,t,s,n){e.removeEventListener(t,s,n)}const Jn=Symbol("_vei");function Tr(e,t,s,n,o=null){const a=e[Jn]||(e[Jn]={}),i=a[t];if(n&&i)i.value=n;else{const[c,r]=Ur(t);if(n){const f=a[t]=Dr(n,o);Ir(e,c,f,r)}else i&&(Mr(e,c,i,r),a[t]=void 0)}}const Yn=/(?:Once|Passive|Capture)$/;function Ur(e){let t;if(Yn.test(e)){t={};let n;for(;n=e.match(Yn);)e=e.slice(0,e.length-n[0].length),t[n[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):Et(e.slice(2)),t]}let Is=0;const Lr=Promise.resolve(),zr=()=>Is||(Lr.then(()=>Is=0),Is=Date.now());function Dr(e,t){const s=n=>{if(!n._vts)n._vts=Date.now();else if(n._vts<=s.attached)return;_e(Nr(n,s.value),t,5,[n])};return s.value=e,s.attached=zr(),s}function Nr(e,t){if(D(t)){const s=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{s.call(e),e._stopped=!0},t.map(n=>o=>!o._stopped&&n&&n(o))}else return t}const Zn=/^on[a-z]/,Fr=(e,t,s,n,o=!1,a,i,c,r)=>{t==="class"?qr(e,n,o):t==="style"?Rr(e,s,n):ps(t)?Gs(t)||Tr(e,t,s,n,i):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):$r(e,t,n,o))?Or(e,t,n,a,i,c,r):(t==="true-value"?e._trueValue=n:t==="false-value"&&(e._falseValue=n),Sr(e,t,n,o))};function $r(e,t,s,n){return n?!!(t==="innerHTML"||t==="textContent"||t in e&&Zn.test(t)&&N(s)):t==="spellcheck"||t==="draggable"||t==="translate"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA"||Zn.test(t)&&ne(s)?!1:t in e}const Hr=se({patchProp:Fr},jr);let Gn;function Br(){return Gn||(Gn=tr(Hr))}const kr=(...e)=>{const t=Br().createApp(...e),{mount:s}=t;return t.mount=n=>{const o=Kr(n);if(!o)return;const a=t._component;!N(a)&&!a.render&&!a.template&&(a.template=o.innerHTML),o.innerHTML="";const i=s(o,!1,o instanceof SVGElement);return o instanceof Element&&(o.removeAttribute("v-cloak"),o.setAttribute("data-v-app","")),i},t};function Kr(e){return ne(e)?document.querySelector(e):e}const Wr="/assets/logotec-ntbKdKRb.png",Pt=(e,t)=>{const s=e.__vccOpts||e;for(const[n,o]of t)s[n]=o;return s},Vr={},ca=e=>(bi("data-v-49da2a7d"),e=e(),yi(),e),Qr={class:"w-full bg-black p-3 flex sticky top-0",id:"NavBar"},Xr=ca(()=>de("div",{class:"w-1/5 flex justify-center",id:"leftArea"},[de("div",{class:"flex flex-col justify-center w-20 text-white text-2xl font-bold"},[de("p",{class:"ml-3"},"Arquitectura"),de("p",null,"Computadoras")])],-1)),Jr={class:"w-4/5 flex flex-row justify-end",id:"rigthArea"},Yr={class:"menuBar flex justify-center items-center mr-16",id:"menuBar"},Zr={class:"flex space-x-4"},Gr=qt('<div class="ml-2 border-l-2" data-v-49da2a7d><div class="ml-2" data-v-49da2a7d><a href="https://drive.google.com/drive/folders/1hFZeoQ8ez7Q8GcBqXd-o6wUMka1dsfmq?usp=sharing" class="rounded text-white px-4 py-2 transition duration-300 ease-in-out hover:bg-white hover:text-black" data-v-49da2a7d> Practicas </a></div></div><div class="ml-2 border-l-2" data-v-49da2a7d><div class="ml-2" data-v-49da2a7d><a href="https://drive.google.com/drive/folders/1v61g-eqaqsVdZVq6PcFd9ceD52MpFdF0?usp=sharing" class="rounded text-white px-4 py-2 transition duration-300 ease-in-out hover:bg-white hover:text-black" data-v-49da2a7d> Tareas </a></div></div>',2),el=ca(()=>de("div",{class:"w-20",id:"topLogo"},[de("img",{src:Wr,alt:""})],-1));function tl(e,t){const s=ko("router-link");return ot(),at("div",Qr,[Xr,de("div",Jr,[de("div",Yr,[de("ul",Zr,[de("li",null,[G(s,{to:"/",class:"rounded text-white px-4 py-2 transition duration-300 ease-in-out hover:bg-white hover:text-black"},{default:Mt(()=>[Ut(" Unidad 1 ")]),_:1})]),de("li",null,[G(s,{to:"/unidad2",class:"rounded text-white px-4 py-2 transition duration-300 ease-in-out hover:bg-white hover:text-black"},{default:Mt(()=>[Ut(" Unidad 2 ")]),_:1})]),de("li",null,[G(s,{to:"/unidad3",class:"rounded text-white px-4 py-2 transition duration-300 ease-in-out hover:bg-white hover:text-black"},{default:Mt(()=>[Ut(" Unidad 3 ")]),_:1})]),de("li",null,[G(s,{to:"/unidad4",class:"rounded text-white px-4 py-2 transition duration-300 ease-in-out hover:bg-white hover:text-black"},{default:Mt(()=>[Ut(" Unidad 4 ")]),_:1})])]),Gr]),el])])}const sl=Pt(Vr,[["render",tl],["__scopeId","data-v-49da2a7d"]]),nl={},ol={class:"w-full bg-black p-3 flex"},al=qt('<div class="flex-1 text-white flex flex-col justify-center"><div class="flex flex-row"><p class="font-medium">Alumno: </p><p class="ml-2"> Jorge Alan Muñiz Romero </p></div><div class="flex flex-row"><p class="font-medium">Hora: </p><p class="ml-2"> 16pm </p></div><div class="flex flex-row"><p class="font-medium">Materia: </p><p class="ml-2"> Arquitectura de computadoras </p></div><div class="flex flex-row"><p class="font-medium">Especialidad: </p><p class="ml-2"> Ingenieria en sistemas computacionales </p></div></div>',1),il=[al];function rl(e,t){return ot(),at("div",ol,il)}const ll=Pt(nl,[["render",rl]]),cl={__name:"App",setup(e){return(t,s)=>{const n=ko("router-view");return ot(),at(Ae,null,[G(sl),G(n),G(ll)],64)}}};/*!
  * vue-router v4.2.5
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */const ft=typeof window<"u";function dl(e){return e.__esModule||e[Symbol.toStringTag]==="Module"}const W=Object.assign;function Ms(e,t){const s={};for(const n in t){const o=t[n];s[n]=we(o)?o.map(e):e(o)}return s}const Nt=()=>{},we=Array.isArray,ul=/\/$/,fl=e=>e.replace(ul,"");function Ts(e,t,s="/"){let n,o={},a="",i="";const c=t.indexOf("#");let r=t.indexOf("?");return c<r&&c>=0&&(r=-1),r>-1&&(n=t.slice(0,r),a=t.slice(r+1,c>-1?c:t.length),o=e(a)),c>-1&&(n=n||t.slice(0,c),i=t.slice(c,t.length)),n=vl(n??t,s),{fullPath:n+(a&&"?")+a+i,path:n,query:o,hash:i}}function pl(e,t){const s=t.query?e(t.query):"";return t.path+(s&&"?")+s+(t.hash||"")}function eo(e,t){return!t||!e.toLowerCase().startsWith(t.toLowerCase())?e:e.slice(t.length)||"/"}function ml(e,t,s){const n=t.matched.length-1,o=s.matched.length-1;return n>-1&&n===o&&_t(t.matched[n],s.matched[o])&&da(t.params,s.params)&&e(t.query)===e(s.query)&&t.hash===s.hash}function _t(e,t){return(e.aliasOf||e)===(t.aliasOf||t)}function da(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(const s in e)if(!hl(e[s],t[s]))return!1;return!0}function hl(e,t){return we(e)?to(e,t):we(t)?to(t,e):e===t}function to(e,t){return we(t)?e.length===t.length&&e.every((s,n)=>s===t[n]):e.length===1&&e[0]===t}function vl(e,t){if(e.startsWith("/"))return e;if(!e)return t;const s=t.split("/"),n=e.split("/"),o=n[n.length-1];(o===".."||o===".")&&n.push("");let a=s.length-1,i,c;for(i=0;i<n.length;i++)if(c=n[i],c!==".")if(c==="..")a>1&&a--;else break;return s.slice(0,a).join("/")+"/"+n.slice(i-(i===n.length?1:0)).join("/")}var Vt;(function(e){e.pop="pop",e.push="push"})(Vt||(Vt={}));var Ft;(function(e){e.back="back",e.forward="forward",e.unknown=""})(Ft||(Ft={}));function gl(e){if(!e)if(ft){const t=document.querySelector("base");e=t&&t.getAttribute("href")||"/",e=e.replace(/^\w+:\/\/[^\/]+/,"")}else e="/";return e[0]!=="/"&&e[0]!=="#"&&(e="/"+e),fl(e)}const xl=/^[^#]+#/;function bl(e,t){return e.replace(xl,"#")+t}function yl(e,t){const s=document.documentElement.getBoundingClientRect(),n=e.getBoundingClientRect();return{behavior:t.behavior,left:n.left-s.left-(t.left||0),top:n.top-s.top-(t.top||0)}}const qs=()=>({left:window.pageXOffset,top:window.pageYOffset});function _l(e){let t;if("el"in e){const s=e.el,n=typeof s=="string"&&s.startsWith("#"),o=typeof s=="string"?n?document.getElementById(s.slice(1)):document.querySelector(s):s;if(!o)return;t=yl(o,e)}else t=e;"scrollBehavior"in document.documentElement.style?window.scrollTo(t):window.scrollTo(t.left!=null?t.left:window.pageXOffset,t.top!=null?t.top:window.pageYOffset)}function so(e,t){return(history.state?history.state.position-t:-1)+e}const Xs=new Map;function wl(e,t){Xs.set(e,t)}function El(e){const t=Xs.get(e);return Xs.delete(e),t}let jl=()=>location.protocol+"//"+location.host;function ua(e,t){const{pathname:s,search:n,hash:o}=t,a=e.indexOf("#");if(a>-1){let c=o.includes(e.slice(a))?e.slice(a).length:1,r=o.slice(c);return r[0]!=="/"&&(r="/"+r),eo(r,"")}return eo(s,e)+n+o}function Cl(e,t,s,n){let o=[],a=[],i=null;const c=({state:h})=>{const _=ua(e,location),R=s.value,S=t.value;let z=0;if(h){if(s.value=_,t.value=h,i&&i===R){i=null;return}z=S?h.position-S.position:0}else n(_);o.forEach(M=>{M(s.value,R,{delta:z,type:Vt.pop,direction:z?z>0?Ft.forward:Ft.back:Ft.unknown})})};function r(){i=s.value}function f(h){o.push(h);const _=()=>{const R=o.indexOf(h);R>-1&&o.splice(R,1)};return a.push(_),_}function u(){const{history:h}=window;h.state&&h.replaceState(W({},h.state,{scroll:qs()}),"")}function m(){for(const h of a)h();a=[],window.removeEventListener("popstate",c),window.removeEventListener("beforeunload",u)}return window.addEventListener("popstate",c),window.addEventListener("beforeunload",u,{passive:!0}),{pauseListeners:r,listen:f,destroy:m}}function no(e,t,s,n=!1,o=!1){return{back:e,current:t,forward:s,replaced:n,position:window.history.length,scroll:o?qs():null}}function ql(e){const{history:t,location:s}=window,n={value:ua(e,s)},o={value:t.state};o.value||a(n.value,{back:null,current:n.value,forward:null,position:t.length-1,replaced:!0,scroll:null},!0);function a(r,f,u){const m=e.indexOf("#"),h=m>-1?(s.host&&document.querySelector("base")?e:e.slice(m))+r:jl()+e+r;try{t[u?"replaceState":"pushState"](f,"",h),o.value=f}catch(_){console.error(_),s[u?"replace":"assign"](h)}}function i(r,f){const u=W({},t.state,no(o.value.back,r,o.value.forward,!0),f,{position:o.value.position});a(r,u,!0),n.value=r}function c(r,f){const u=W({},o.value,t.state,{forward:r,scroll:qs()});a(u.current,u,!0);const m=W({},no(n.value,r,null),{position:u.position+1},f);a(r,m,!1),n.value=r}return{location:n,state:o,push:c,replace:i}}function Pl(e){e=gl(e);const t=ql(e),s=Cl(e,t.state,t.location,t.replace);function n(a,i=!0){i||s.pauseListeners(),history.go(a)}const o=W({location:"",base:e,go:n,createHref:bl.bind(null,e)},t,s);return Object.defineProperty(o,"location",{enumerable:!0,get:()=>t.location.value}),Object.defineProperty(o,"state",{enumerable:!0,get:()=>t.state.value}),o}function Rl(e){return typeof e=="string"||e&&typeof e=="object"}function fa(e){return typeof e=="string"||typeof e=="symbol"}const ke={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},pa=Symbol("");var oo;(function(e){e[e.aborted=4]="aborted",e[e.cancelled=8]="cancelled",e[e.duplicated=16]="duplicated"})(oo||(oo={}));function wt(e,t){return W(new Error,{type:e,[pa]:!0},t)}function Le(e,t){return e instanceof Error&&pa in e&&(t==null||!!(e.type&t))}const ao="[^/]+?",Al={sensitive:!1,strict:!1,start:!0,end:!0},Sl=/[.+*?^${}()[\]/\\]/g;function Ol(e,t){const s=W({},Al,t),n=[];let o=s.start?"^":"";const a=[];for(const f of e){const u=f.length?[]:[90];s.strict&&!f.length&&(o+="/");for(let m=0;m<f.length;m++){const h=f[m];let _=40+(s.sensitive?.25:0);if(h.type===0)m||(o+="/"),o+=h.value.replace(Sl,"\\$&"),_+=40;else if(h.type===1){const{value:R,repeatable:S,optional:z,regexp:M}=h;a.push({name:R,repeatable:S,optional:z});const T=M||ao;if(T!==ao){_+=10;try{new RegExp(`(${T})`)}catch(U){throw new Error(`Invalid custom RegExp for param "${R}" (${T}): `+U.message)}}let H=S?`((?:${T})(?:/(?:${T}))*)`:`(${T})`;m||(H=z&&f.length<2?`(?:/${H})`:"/"+H),z&&(H+="?"),o+=H,_+=20,z&&(_+=-8),S&&(_+=-20),T===".*"&&(_+=-50)}u.push(_)}n.push(u)}if(s.strict&&s.end){const f=n.length-1;n[f][n[f].length-1]+=.7000000000000001}s.strict||(o+="/?"),s.end?o+="$":s.strict&&(o+="(?:/|$)");const i=new RegExp(o,s.sensitive?"":"i");function c(f){const u=f.match(i),m={};if(!u)return null;for(let h=1;h<u.length;h++){const _=u[h]||"",R=a[h-1];m[R.name]=_&&R.repeatable?_.split("/"):_}return m}function r(f){let u="",m=!1;for(const h of e){(!m||!u.endsWith("/"))&&(u+="/"),m=!1;for(const _ of h)if(_.type===0)u+=_.value;else if(_.type===1){const{value:R,repeatable:S,optional:z}=_,M=R in f?f[R]:"";if(we(M)&&!S)throw new Error(`Provided param "${R}" is an array but it is not repeatable (* or + modifiers)`);const T=we(M)?M.join("/"):M;if(!T)if(z)h.length<2&&(u.endsWith("/")?u=u.slice(0,-1):m=!0);else throw new Error(`Missing required param "${R}"`);u+=T}}return u||"/"}return{re:i,score:n,keys:a,parse:c,stringify:r}}function Il(e,t){let s=0;for(;s<e.length&&s<t.length;){const n=t[s]-e[s];if(n)return n;s++}return e.length<t.length?e.length===1&&e[0]===40+40?-1:1:e.length>t.length?t.length===1&&t[0]===40+40?1:-1:0}function Ml(e,t){let s=0;const n=e.score,o=t.score;for(;s<n.length&&s<o.length;){const a=Il(n[s],o[s]);if(a)return a;s++}if(Math.abs(o.length-n.length)===1){if(io(n))return 1;if(io(o))return-1}return o.length-n.length}function io(e){const t=e[e.length-1];return e.length>0&&t[t.length-1]<0}const Tl={type:0,value:""},Ul=/[a-zA-Z0-9_]/;function Ll(e){if(!e)return[[]];if(e==="/")return[[Tl]];if(!e.startsWith("/"))throw new Error(`Invalid path "${e}"`);function t(_){throw new Error(`ERR (${s})/"${f}": ${_}`)}let s=0,n=s;const o=[];let a;function i(){a&&o.push(a),a=[]}let c=0,r,f="",u="";function m(){f&&(s===0?a.push({type:0,value:f}):s===1||s===2||s===3?(a.length>1&&(r==="*"||r==="+")&&t(`A repeatable param (${f}) must be alone in its segment. eg: '/:ids+.`),a.push({type:1,value:f,regexp:u,repeatable:r==="*"||r==="+",optional:r==="*"||r==="?"})):t("Invalid state to consume buffer"),f="")}function h(){f+=r}for(;c<e.length;){if(r=e[c++],r==="\\"&&s!==2){n=s,s=4;continue}switch(s){case 0:r==="/"?(f&&m(),i()):r===":"?(m(),s=1):h();break;case 4:h(),s=n;break;case 1:r==="("?s=2:Ul.test(r)?h():(m(),s=0,r!=="*"&&r!=="?"&&r!=="+"&&c--);break;case 2:r===")"?u[u.length-1]=="\\"?u=u.slice(0,-1)+r:s=3:u+=r;break;case 3:m(),s=0,r!=="*"&&r!=="?"&&r!=="+"&&c--,u="";break;default:t("Unknown state");break}}return s===2&&t(`Unfinished custom RegExp for param "${f}"`),m(),i(),o}function zl(e,t,s){const n=Ol(Ll(e.path),s),o=W(n,{record:e,parent:t,children:[],alias:[]});return t&&!o.record.aliasOf==!t.record.aliasOf&&t.children.push(o),o}function Dl(e,t){const s=[],n=new Map;t=co({strict:!1,end:!0,sensitive:!1},t);function o(u){return n.get(u)}function a(u,m,h){const _=!h,R=Nl(u);R.aliasOf=h&&h.record;const S=co(t,u),z=[R];if("alias"in u){const H=typeof u.alias=="string"?[u.alias]:u.alias;for(const U of H)z.push(W({},R,{components:h?h.record.components:R.components,path:U,aliasOf:h?h.record:R}))}let M,T;for(const H of z){const{path:U}=H;if(m&&U[0]!=="/"){const oe=m.record.path,le=oe[oe.length-1]==="/"?"":"/";H.path=m.record.path+(U&&le+U)}if(M=zl(H,m,S),h?h.alias.push(M):(T=T||M,T!==M&&T.alias.push(M),_&&u.name&&!lo(M)&&i(u.name)),R.children){const oe=R.children;for(let le=0;le<oe.length;le++)a(oe[le],M,h&&h.children[le])}h=h||M,(M.record.components&&Object.keys(M.record.components).length||M.record.name||M.record.redirect)&&r(M)}return T?()=>{i(T)}:Nt}function i(u){if(fa(u)){const m=n.get(u);m&&(n.delete(u),s.splice(s.indexOf(m),1),m.children.forEach(i),m.alias.forEach(i))}else{const m=s.indexOf(u);m>-1&&(s.splice(m,1),u.record.name&&n.delete(u.record.name),u.children.forEach(i),u.alias.forEach(i))}}function c(){return s}function r(u){let m=0;for(;m<s.length&&Ml(u,s[m])>=0&&(u.record.path!==s[m].record.path||!ma(u,s[m]));)m++;s.splice(m,0,u),u.record.name&&!lo(u)&&n.set(u.record.name,u)}function f(u,m){let h,_={},R,S;if("name"in u&&u.name){if(h=n.get(u.name),!h)throw wt(1,{location:u});S=h.record.name,_=W(ro(m.params,h.keys.filter(T=>!T.optional).map(T=>T.name)),u.params&&ro(u.params,h.keys.map(T=>T.name))),R=h.stringify(_)}else if("path"in u)R=u.path,h=s.find(T=>T.re.test(R)),h&&(_=h.parse(R),S=h.record.name);else{if(h=m.name?n.get(m.name):s.find(T=>T.re.test(m.path)),!h)throw wt(1,{location:u,currentLocation:m});S=h.record.name,_=W({},m.params,u.params),R=h.stringify(_)}const z=[];let M=h;for(;M;)z.unshift(M.record),M=M.parent;return{name:S,path:R,params:_,matched:z,meta:$l(z)}}return e.forEach(u=>a(u)),{addRoute:a,resolve:f,removeRoute:i,getRoutes:c,getRecordMatcher:o}}function ro(e,t){const s={};for(const n of t)n in e&&(s[n]=e[n]);return s}function Nl(e){return{path:e.path,redirect:e.redirect,name:e.name,meta:e.meta||{},aliasOf:void 0,beforeEnter:e.beforeEnter,props:Fl(e),children:e.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in e?e.components||null:e.component&&{default:e.component}}}function Fl(e){const t={},s=e.props||!1;if("component"in e)t.default=s;else for(const n in e.components)t[n]=typeof s=="object"?s[n]:s;return t}function lo(e){for(;e;){if(e.record.aliasOf)return!0;e=e.parent}return!1}function $l(e){return e.reduce((t,s)=>W(t,s.meta),{})}function co(e,t){const s={};for(const n in e)s[n]=n in t?t[n]:e[n];return s}function ma(e,t){return t.children.some(s=>s===e||ma(e,s))}const ha=/#/g,Hl=/&/g,Bl=/\//g,kl=/=/g,Kl=/\?/g,va=/\+/g,Wl=/%5B/g,Vl=/%5D/g,ga=/%5E/g,Ql=/%60/g,xa=/%7B/g,Xl=/%7C/g,ba=/%7D/g,Jl=/%20/g;function xn(e){return encodeURI(""+e).replace(Xl,"|").replace(Wl,"[").replace(Vl,"]")}function Yl(e){return xn(e).replace(xa,"{").replace(ba,"}").replace(ga,"^")}function Js(e){return xn(e).replace(va,"%2B").replace(Jl,"+").replace(ha,"%23").replace(Hl,"%26").replace(Ql,"`").replace(xa,"{").replace(ba,"}").replace(ga,"^")}function Zl(e){return Js(e).replace(kl,"%3D")}function Gl(e){return xn(e).replace(ha,"%23").replace(Kl,"%3F")}function ec(e){return e==null?"":Gl(e).replace(Bl,"%2F")}function fs(e){try{return decodeURIComponent(""+e)}catch{}return""+e}function tc(e){const t={};if(e===""||e==="?")return t;const n=(e[0]==="?"?e.slice(1):e).split("&");for(let o=0;o<n.length;++o){const a=n[o].replace(va," "),i=a.indexOf("="),c=fs(i<0?a:a.slice(0,i)),r=i<0?null:fs(a.slice(i+1));if(c in t){let f=t[c];we(f)||(f=t[c]=[f]),f.push(r)}else t[c]=r}return t}function uo(e){let t="";for(let s in e){const n=e[s];if(s=Zl(s),n==null){n!==void 0&&(t+=(t.length?"&":"")+s);continue}(we(n)?n.map(a=>a&&Js(a)):[n&&Js(n)]).forEach(a=>{a!==void 0&&(t+=(t.length?"&":"")+s,a!=null&&(t+="="+a))})}return t}function sc(e){const t={};for(const s in e){const n=e[s];n!==void 0&&(t[s]=we(n)?n.map(o=>o==null?null:""+o):n==null?n:""+n)}return t}const nc=Symbol(""),fo=Symbol(""),bn=Symbol(""),ya=Symbol(""),Ys=Symbol("");function Ot(){let e=[];function t(n){return e.push(n),()=>{const o=e.indexOf(n);o>-1&&e.splice(o,1)}}function s(){e=[]}return{add:t,list:()=>e.slice(),reset:s}}function We(e,t,s,n,o){const a=n&&(n.enterCallbacks[o]=n.enterCallbacks[o]||[]);return()=>new Promise((i,c)=>{const r=m=>{m===!1?c(wt(4,{from:s,to:t})):m instanceof Error?c(m):Rl(m)?c(wt(2,{from:t,to:m})):(a&&n.enterCallbacks[o]===a&&typeof m=="function"&&a.push(m),i())},f=e.call(n&&n.instances[o],t,s,r);let u=Promise.resolve(f);e.length<3&&(u=u.then(r)),u.catch(m=>c(m))})}function Us(e,t,s,n){const o=[];for(const a of e)for(const i in a.components){let c=a.components[i];if(!(t!=="beforeRouteEnter"&&!a.instances[i]))if(oc(c)){const f=(c.__vccOpts||c)[t];f&&o.push(We(f,s,n,a,i))}else{let r=c();o.push(()=>r.then(f=>{if(!f)return Promise.reject(new Error(`Couldn't resolve component "${i}" at "${a.path}"`));const u=dl(f)?f.default:f;a.components[i]=u;const h=(u.__vccOpts||u)[t];return h&&We(h,s,n,a,i)()}))}}return o}function oc(e){return typeof e=="object"||"displayName"in e||"props"in e||"__vccOpts"in e}function po(e){const t=Ne(bn),s=Ne(ya),n=xe(()=>t.resolve(vt(e.to))),o=xe(()=>{const{matched:r}=n.value,{length:f}=r,u=r[f-1],m=s.matched;if(!u||!m.length)return-1;const h=m.findIndex(_t.bind(null,u));if(h>-1)return h;const _=mo(r[f-2]);return f>1&&mo(u)===_&&m[m.length-1].path!==_?m.findIndex(_t.bind(null,r[f-2])):h}),a=xe(()=>o.value>-1&&lc(s.params,n.value.params)),i=xe(()=>o.value>-1&&o.value===s.matched.length-1&&da(s.params,n.value.params));function c(r={}){return rc(r)?t[vt(e.replace)?"replace":"push"](vt(e.to)).catch(Nt):Promise.resolve()}return{route:n,href:xe(()=>n.value.href),isActive:a,isExactActive:i,navigate:c}}const ac=Vo({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:po,setup(e,{slots:t}){const s=bs(po(e)),{options:n}=Ne(bn),o=xe(()=>({[ho(e.activeClass,n.linkActiveClass,"router-link-active")]:s.isActive,[ho(e.exactActiveClass,n.linkExactActiveClass,"router-link-exact-active")]:s.isExactActive}));return()=>{const a=t.default&&t.default(s);return e.custom?a:la("a",{"aria-current":s.isExactActive?e.ariaCurrentValue:null,href:s.href,onClick:s.navigate,class:o.value},a)}}}),ic=ac;function rc(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&!e.defaultPrevented&&!(e.button!==void 0&&e.button!==0)){if(e.currentTarget&&e.currentTarget.getAttribute){const t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function lc(e,t){for(const s in t){const n=t[s],o=e[s];if(typeof n=="string"){if(n!==o)return!1}else if(!we(o)||o.length!==n.length||n.some((a,i)=>a!==o[i]))return!1}return!0}function mo(e){return e?e.aliasOf?e.aliasOf.path:e.path:""}const ho=(e,t,s)=>e??t??s,cc=Vo({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(e,{attrs:t,slots:s}){const n=Ne(Ys),o=xe(()=>e.route||n.value),a=Ne(fo,0),i=xe(()=>{let f=vt(a);const{matched:u}=o.value;let m;for(;(m=u[f])&&!m.components;)f++;return f}),c=xe(()=>o.value.matched[i.value]);os(fo,xe(()=>i.value+1)),os(nc,c),os(Ys,o);const r=ri();return ss(()=>[r.value,c.value,e.name],([f,u,m],[h,_,R])=>{u&&(u.instances[m]=f,_&&_!==u&&f&&f===h&&(u.leaveGuards.size||(u.leaveGuards=_.leaveGuards),u.updateGuards.size||(u.updateGuards=_.updateGuards))),f&&u&&(!_||!_t(u,_)||!h)&&(u.enterCallbacks[m]||[]).forEach(S=>S(f))},{flush:"post"}),()=>{const f=o.value,u=e.name,m=c.value,h=m&&m.components[u];if(!h)return vo(s.default,{Component:h,route:f});const _=m.props[u],R=_?_===!0?f.params:typeof _=="function"?_(f):_:null,z=la(h,W({},R,t,{onVnodeUnmounted:M=>{M.component.isUnmounted&&(m.instances[u]=null)},ref:r}));return vo(s.default,{Component:z,route:f})||z}}});function vo(e,t){if(!e)return null;const s=e(t);return s.length===1?s[0]:s}const dc=cc;function uc(e){const t=Dl(e.routes,e),s=e.parseQuery||tc,n=e.stringifyQuery||uo,o=e.history,a=Ot(),i=Ot(),c=Ot(),r=li(ke);let f=ke;ft&&e.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const u=Ms.bind(null,g=>""+g),m=Ms.bind(null,ec),h=Ms.bind(null,fs);function _(g,q){let j,A;return fa(g)?(j=t.getRecordMatcher(g),A=q):A=g,t.addRoute(A,j)}function R(g){const q=t.getRecordMatcher(g);q&&t.removeRoute(q)}function S(){return t.getRoutes().map(g=>g.record)}function z(g){return!!t.getRecordMatcher(g)}function M(g,q){if(q=W({},q||r.value),typeof g=="string"){const p=Ts(s,g,q.path),v=t.resolve({path:p.path},q),x=o.createHref(p.fullPath);return W(p,v,{params:h(v.params),hash:fs(p.hash),redirectedFrom:void 0,href:x})}let j;if("path"in g)j=W({},g,{path:Ts(s,g.path,q.path).path});else{const p=W({},g.params);for(const v in p)p[v]==null&&delete p[v];j=W({},g,{params:m(p)}),q.params=m(q.params)}const A=t.resolve(j,q),K=g.hash||"";A.params=u(h(A.params));const l=pl(n,W({},g,{hash:Yl(K),path:A.path})),d=o.createHref(l);return W({fullPath:l,hash:K,query:n===uo?sc(g.query):g.query||{}},A,{redirectedFrom:void 0,href:d})}function T(g){return typeof g=="string"?Ts(s,g,r.value.path):W({},g)}function H(g,q){if(f!==g)return wt(8,{from:q,to:g})}function U(g){return Ee(g)}function oe(g){return U(W(T(g),{replace:!0}))}function le(g){const q=g.matched[g.matched.length-1];if(q&&q.redirect){const{redirect:j}=q;let A=typeof j=="function"?j(g):j;return typeof A=="string"&&(A=A.includes("?")||A.includes("#")?A=T(A):{path:A},A.params={}),W({query:g.query,hash:g.hash,params:"path"in A?{}:g.params},A)}}function Ee(g,q){const j=f=M(g),A=r.value,K=g.state,l=g.force,d=g.replace===!0,p=le(j);if(p)return Ee(W(T(p),{state:typeof p=="object"?W({},K,p.state):K,force:l,replace:d}),q||j);const v=j;v.redirectedFrom=q;let x;return!l&&ml(n,A,j)&&(x=wt(16,{to:v,from:A}),qe(A,A,!0,!1)),(x?Promise.resolve(x):je(v,A)).catch(b=>Le(b)?Le(b,2)?b:He(b):k(b,v,A)).then(b=>{if(b){if(Le(b,2))return Ee(W({replace:d},T(b.to),{state:typeof b.to=="object"?W({},K,b.to.state):K,force:l}),q||v)}else b=Je(v,A,!0,d,K);return $e(v,A,b),b})}function Te(g,q){const j=H(g,q);return j?Promise.reject(j):Promise.resolve()}function it(g){const q=ct.values().next().value;return q&&typeof q.runWithContext=="function"?q.runWithContext(g):g()}function je(g,q){let j;const[A,K,l]=fc(g,q);j=Us(A.reverse(),"beforeRouteLeave",g,q);for(const p of A)p.leaveGuards.forEach(v=>{j.push(We(v,g,q))});const d=Te.bind(null,g,q);return j.push(d),ae(j).then(()=>{j=[];for(const p of a.list())j.push(We(p,g,q));return j.push(d),ae(j)}).then(()=>{j=Us(K,"beforeRouteUpdate",g,q);for(const p of K)p.updateGuards.forEach(v=>{j.push(We(v,g,q))});return j.push(d),ae(j)}).then(()=>{j=[];for(const p of l)if(p.beforeEnter)if(we(p.beforeEnter))for(const v of p.beforeEnter)j.push(We(v,g,q));else j.push(We(p.beforeEnter,g,q));return j.push(d),ae(j)}).then(()=>(g.matched.forEach(p=>p.enterCallbacks={}),j=Us(l,"beforeRouteEnter",g,q),j.push(d),ae(j))).then(()=>{j=[];for(const p of i.list())j.push(We(p,g,q));return j.push(d),ae(j)}).catch(p=>Le(p,8)?p:Promise.reject(p))}function $e(g,q,j){c.list().forEach(A=>it(()=>A(g,q,j)))}function Je(g,q,j,A,K){const l=H(g,q);if(l)return l;const d=q===ke,p=ft?history.state:{};j&&(A||d?o.replace(g.fullPath,W({scroll:d&&p&&p.scroll},K)):o.push(g.fullPath,K)),r.value=g,qe(g,q,j,d),He()}let Ce;function Rt(){Ce||(Ce=o.listen((g,q,j)=>{if(!Qt.listening)return;const A=M(g),K=le(A);if(K){Ee(W(K,{replace:!0}),A).catch(Nt);return}f=A;const l=r.value;ft&&wl(so(l.fullPath,j.delta),qs()),je(A,l).catch(d=>Le(d,12)?d:Le(d,2)?(Ee(d.to,A).then(p=>{Le(p,20)&&!j.delta&&j.type===Vt.pop&&o.go(-1,!1)}).catch(Nt),Promise.reject()):(j.delta&&o.go(-j.delta,!1),k(d,A,l))).then(d=>{d=d||Je(A,l,!1),d&&(j.delta&&!Le(d,8)?o.go(-j.delta,!1):j.type===Vt.pop&&Le(d,20)&&o.go(-1,!1)),$e(A,l,d)}).catch(Nt)}))}let rt=Ot(),ee=Ot(),Q;function k(g,q,j){He(g);const A=ee.list();return A.length?A.forEach(K=>K(g,q,j)):console.error(g),Promise.reject(g)}function Ue(){return Q&&r.value!==ke?Promise.resolve():new Promise((g,q)=>{rt.add([g,q])})}function He(g){return Q||(Q=!g,Rt(),rt.list().forEach(([q,j])=>g?j(g):q()),rt.reset()),g}function qe(g,q,j,A){const{scrollBehavior:K}=e;if(!ft||!K)return Promise.resolve();const l=!j&&El(so(g.fullPath,0))||(A||!j)&&history.state&&history.state.scroll||null;return Do().then(()=>K(g,q,l)).then(d=>d&&_l(d)).catch(d=>k(d,g,q))}const ue=g=>o.go(g);let lt;const ct=new Set,Qt={currentRoute:r,listening:!0,addRoute:_,removeRoute:R,hasRoute:z,getRoutes:S,resolve:M,options:e,push:U,replace:oe,go:ue,back:()=>ue(-1),forward:()=>ue(1),beforeEach:a.add,beforeResolve:i.add,afterEach:c.add,onError:ee.add,isReady:Ue,install(g){const q=this;g.component("RouterLink",ic),g.component("RouterView",dc),g.config.globalProperties.$router=q,Object.defineProperty(g.config.globalProperties,"$route",{enumerable:!0,get:()=>vt(r)}),ft&&!lt&&r.value===ke&&(lt=!0,U(o.location).catch(K=>{}));const j={};for(const K in ke)Object.defineProperty(j,K,{get:()=>r.value[K],enumerable:!0});g.provide(bn,q),g.provide(ya,Ao(j)),g.provide(Ys,r);const A=g.unmount;ct.add(g),g.unmount=function(){ct.delete(g),ct.size<1&&(f=ke,Ce&&Ce(),Ce=null,r.value=ke,lt=!1,Q=!1),A()}}};function ae(g){return g.reduce((q,j)=>q.then(()=>it(j)),Promise.resolve())}return Qt}function fc(e,t){const s=[],n=[],o=[],a=Math.max(t.matched.length,e.matched.length);for(let i=0;i<a;i++){const c=t.matched[i];c&&(e.matched.find(f=>_t(f,c))?n.push(c):s.push(c));const r=e.matched[i];r&&(t.matched.find(f=>_t(f,r))||o.push(r))}return[s,n,o]}const pc="/assets/bus-p8XZW8eM.jpg",mc="/assets/bus2-2cu7RKpE.jpg",hc="/assets/bus3-iiVQWIoF.jpg",vc="/assets/bus4-vYSEPTIb.jpg",gc="/assets/cpu-7igkfBPy.jpeg",xc="/assets/bua-OK6T3og2.jpg",bc="/assets/cisc-yzdzigwM.jpg",yc="/assets/risc-aCnLA151.jpg",_c="/assets/estructuradebus-PqCNvqyb.jpg",wc="/assets/ram-A24bCjuf.jpeg",Ec="/assets/accesomemoria-9ip6kAcw.jpg",jc="/assets/normalizacionbus-QZ6lHFHz.jpg",Cc="/assets/modovirtual-arWrWSzD.jpg",qc={},Pc={class:"bg-gray-300 p-5"},Rc=qt('<div class="container mx-auto rounded-lg bg-white p-8"><div class="flex justify-center bg-black p-3 rounded"><h1 class="text-center text-4xl text-white font-medium">1. Arquitectura de Computadoras</h1></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.1.1 Arquitecturas Clásicas</h2><div class="flex flex-row justify-center"><div class="w-1/5"><p>Estas arquitecturas se desarrollaron en las primeras computadoras electromecánicas y de tubos de vacío. Aun son usadas en procesadores empotrados de gama baja y son la base de la mayoría de las arquitecturas modernas.</p></div><div class="w-2/5"><img src="'+pc+'" alt=""></div><div class="w-1/5"><p>Una desventaja es que el bus de datos y direcciones único se convierte en un cuello de botella por el cual debe pasar toda la información que se lee de o se escribe a la memoria, obligando a que todos los accesos a esta sean secuenciales.</p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.1.1 Arquitectura Harvard</h2><div class="flex flex-row justify-evenly mt-5"><div class="w-2/5"><p>El programa se almacena como un código numérico en la memoria, el hecho de tener un bus separado para el programa y otro para los datos permite que se lea el código de operación de una instrucción, al mismo tiempo se lee de la memoria de datos los operados de la instrucción previa.</p></div><div class="w-2/5"><img src="'+mc+'" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.1.2 Arquitecturas Segmentadas</h2><div class="flex flex-row justify-evenly mt-5"><div class="w-2/5"><img src="'+hc+'" alt=""></div><div class="w-2/5"><p>Buscan mejorar el desempeño realizando paralelamente varias etapas del ciclo de instrucción al mismo tiempo. El procesador se divide en varias unidades funcionales independientes y se dividen entre ellas el procesamiento de las instrucciones.</p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.1.3 Arquitecturas de Multi-procesamiento.</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p>Cuando se desea incrementar el desempeño más alla de lo que permite la técnica de segmentación del cauce, se requiere utilizar más de un procesador para la ejecución del programa de aplicación.</p><p class="mt-5">Las CPU multiprocesamiento se clasifican en: SISO, SIMO, MISO, MIMO</p></div><div class="w-4/5"><img class="mt-5" src="'+vc+'" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2 Unidad Central de Procesamiento</h2><div class="flex flex-row justify-evenly mt-5"><div class="w-2/5 text-2 xl"><p>Es un un componente básico de todo dispositivo que procesa datos y realiza cálculos matemáticos-informáticos. El CPU es la pieza fundamental de todo dispositivo, es considerado el cerebro de un sistema. En primer lugar, es el encargado de recibir e interpretar datos y ejecutar las secuencias de instrucciones a realizar por cada programa valiéndose de operaciones aritméticas y matemáticas.</p></div><div class="w-2/5"><img src="'+gc+'" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.1.1 Arquitectura</h2><div class="flex flex-row justify-evenly mt-5"><div class="w-2/5"><img src="'+xc+'" alt=""></div><div class="w-2/5 text-2xl"><p>Hoy en día, en la actualidad han aparecido arquitecturas híbridas entre la Von Newmann y la Harvard, buscando conservar la flexibilidad, pero optimizando el rendimiento. Los programas cada vez más grandes y complejos demandan mayor velocidad en el procesamiento de información como lo que implica la elección de microprocesadores más rápidos y eficientes. Para asignarle un diseño a un microprocesador se debe identificar cuál será su función principal.</p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.1.2 Tipos</h2><div class="flex flex-row justify-center mt-5 text-2xl"><div class="w-4/5"><p class="mt-2"> Los diseñadores de hardware inventan numerosas tecnologías &amp; herramientas para implementar la arquitectura deseada con el fin de satisfacer estas necesidades. La arquitectura de hardware puede implementarse para ser específica de hardware o específica de software, pero según la aplicación se utilizan ambas en la cantidad requerida. En lo que respecta al hardware del procesador, existen dos tipos de conceptos para implementar la arquitectura de hardware del procesador. El primero es RISC y el otro es CISC. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.1.3 Características</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p>Arquitectura CISC: El enfoque CISC intenta minimizar el número de instrucciones por programa, sacrificando el número de ciclos por instrucción. Los ordenadores basados en la arquitectura CISC están diseñados para disminuir el coste de la memoria</p></div><div class="w-4/5"><p>Arquitectura RISC: se utiliza en dispositivos portátiles debido a su eficiencia energética. RISC hace lo contrario, reducir los ciclos por instrucción a costa del número de instrucciones por programa El pipelining es una de las características únicas de RISC.</p></div></div><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><img src="'+bc+'" alt=""></div><div class="w-4/5"><img src="'+yc+'" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.1.4 Funcionamiento</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> ALU: Es un circuito digital que realiza como su nombre lo indica las operaciones aritméticas y lógicas entre los datos de un circuito; suma, resta, divide y multiplica, así como establece comparaciones lógicas a través de las condicionales lógicas &quot; si &quot;,&quot; no &quot;,&quot; o &quot;. </p><p class="mt-5"> Unidad de control: Circuito secuencial que implementa el denominado &quot;ciclo de instrucción&quot;, permitiendo acceder a la siguiente instrucción de un programa, leer sus operandos, efectuar la operación indicada en la ALU y guardar el resultado de la misma. Una de sus funciones es la decodificación de instrucciones. </p><p class="mt-5"> Registros: Los registros que encuentran dentro de cada procesador su función principal es almacenar los valores de cada uno de los datos, comandos, instrucciones o estados binarios que son de los que ordenan qué datos deben procesarse, así como la forma en la que se debe procesar o realizar. </p><p class="mt-5"> Buses: Consta de un camino que permite comunicar selectivamente un cierto número de componentes o dispositivos, de acuerdo a unas ciertas reglas o normas de conexión. </p></div><div class="w-3/5"><img src="'+_c+'" class="w-full" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.2 Memoria</h2><h3 class="flex justify-center text-3xl font-bold">1.2.2.1 Conceptos básicos de manejo de memoria</h3><div class="flex flex-row justify-center mt-5"><div class="w-2/5 text-xl"><p class="mt-5"> Memoria Física: Es la memoria real instalada en el hardware de la computadora. Incluye componentes como la memoria RAM y la memoria caché. </p><p class="mt-5"> Memoria Virtual: Es una extensión de la memoria RAM que utiliza espacio en el disco duro. Permite que las aplicaciones utilicen más memoria de la que está físicamente presente. </p><p class="mt-5"> Administrador de memoria: Es el componente que se encarga de gestionar el uso de la memoria. Se asegura de que los programas reciban la cantidad adecuada de memoria. </p><p class="mt-5"> Asignación de Memoria: Es el proceso de reservar una porción de la memoria para que un programa pueda utilizarla. Puede realizarse durante el inicio del programa o durante la ejecución . </p><p class="mt-5"> Gestión de Memoria: Involucra llevar un registro de qué partes de la memoria están en uso y cuáles están libres. Esto incluye la asignación, liberación y reubicación de bloques de memoria. </p><p class="mt-5"> Thrashing: Ocurre cuando un sistema está ocupado en gran medida en intercambiar datos entre la memoria principal y la virtual debido a la falta de suficiente memoria física. </p></div><div class="w-2/5"><img src="'+wc+'" class="w-full"></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.2.2 Memoria principal semiconductora</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> La memoria principal semiconductora, es una categoría de memoria de computadora que utiliza dispositivos semiconductores para almacenar datos de forma electrónica. La memoria principal semiconductora utiliza circuitos y transistores para retener y acceder a la información de manera mucho más rápida. </p><p class="mt-5"> Tipos: Memoria RAM, Memoria Caché, Memoria VRAM y Memoria de estado sólido </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.2.3 Memoria Caché</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Es una forma de memoria de alta velocidad que se encuentra entre la memoria RAM (principal) y la unidad central de procesamiento (CPU) en un sistema informático. Su objetivo principal es mejorar el rendimiento al almacenar temporalmente datos y programas que la CPU utiliza con frecuencia. La caché actúa como un búfer rápido que permite a la CPU acceder rápidamente a los datos que necesita. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.3 Dispositivos Entrada/Salida</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Son componentes que permiten la comunicación entre una computadora y el mundo exterior. Estos dispositivos se utilizan para ingresar datos a la computadora (datos de entrada) o enviar datos desde la computadora (datos de salida). </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.3.1 Modulos E/S</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Componentes esenciales en la arquitectura de una computadora que facilitan la comunicación entre la Unidad Central de Procesamiento (CPU) y los dispositivos de entrada/salida (E/S). Su función principal es gestionar la transferencia de datos entre la CPU y los dispositivos externos, garantizando que la comunicación sea eficiente y confiable. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.3.2 E/S programada</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> La E/S (Entrada/Salida) programada se refiere a un enfoque en la informática donde el programa controla directamente las operaciones de entrada y salida de datos hacia y desde los dispositivos periféricos. Esto significa que el programa es responsable de leer y escribir datos en los dispositivos de manera manual en lugar de dejar que el sistema operativo gestione automáticamente estas operaciones. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.3.3 E/S mediante interruptores</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Es un método de gestión de dispositivos de entrada/salida en una computadora que permite que los dispositivos de E/S interrumpan la CPU cuando están listos para transmitir datos o cuando se produce una condición especial. </p><p class="mt-5"> ¿Cuándo se utiliza? Se utiliza frecuentemente en sistemas multitarea,operaciones concurrentes y respuesta rápida </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.3.4 Acceso directo a la memoria </h2><div class="flex flex-row justify-evenly mt-5"><div class="w-2/5"><img src="'+Ec+'" alt=""></div><div class="w-2/5 text-2xl"><p> Es una técnica utilizada en arquitectura de computadoras que permite a dispositivos de entrada/salida (E/S) transferir datos directamente entre ellos y la memoria principal de la computadora sin la intervención constante de la Unidad Central de Procesamiento (CPU). Esta técnica es especialmente útil para acelerar las operaciones de E/S y liberar a la CPU para realizar otras tareas. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.3.5 Canales y procesadores E/S</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Son componentes fundamentales en la arquitectura de computadoras que se utilizan para gestionar múltiples dispositivos de entrada/salida (E/S) de manera eficiente y coordinada. Estos componentes permiten que la computadora maneje un gran número de operaciones de E/S de manera concurrente sin sobrecargar la Unidad Central de Procesamiento (CPU). </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.4 Buses</h2><h3 class="flex justify-center text-3xl font-bold">1.2.4.1 Bus local</h3><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Un bus local es un bus informático que se conecta directamente, o casi directamente, desde la unidad central de procesamiento (CPU) a una o más ranuras en el bus de expansión . La importancia de la conexión directa a la CPU es evitar el cuello de botella creado por el bus de expansión, proporcionando así un rendimiento rápido. </p></div></div></div><div class="container mx-auto mt-10"><h3 class="flex justify-center text-3xl font-bold">1.2.4.2 Bus de datos</h3><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Bus de datos es un mecanismo de comunicación que une los dispositivos electrónicos en una computadora. Esta conexión les permite intercambiar información entre ellos, permitiendo así al procesador realizar operaciones y almacenar y recuperar datos. </p></div></div></div><div class="container mx-auto mt-10"><h3 class="flex justify-center text-3xl font-bold">1.2.4.3 Bus de direcciones</h3><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> El bus de direcciones es el canal del microprocesador, que es independiente del bus de datos y que es donde se establece la dirección de memoria del dato que se está transmitiendo. </p></div></div></div><div class="container mx-auto mt-10"><h3 class="flex justify-center text-3xl font-bold">1.2.4.4 Bus de control</h3><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Es un canal de comunicación que se utiliza para conectar varios componentes de un sistema. El bus de control permite a los dispositivos comunicarse, compartir información y recibir instrucciones. </p></div></div></div><div class="container mx-auto mt-10"><h3 class="flex justify-center text-3xl font-bold">1.2.4.5 Normalización de Buses</h3><div class="mt-5 text-xl w-full flex justify-center"><div class="w-4/5"><p class="mt-5"> Para facilitar la interacción entre componentes de distintos fabricantes los buses se han normalizado y siguen un estándar. </p><p class="mt-5"> Estándar: Protocolos de transmisión de datos. QR Velocidades y temporización de las transferencias. QR Anchuras de los sub-buses. Sistema físico de conexión. </p><p class="mt-5"> Nivel mecánico: Tipo de soporte, el número de hilos del bus, el tipo de conector, etc. </p><p class="mt-5"> Nivel eléctrico: Se define la forma en la que los distintos dispositivos deben conectarse eléctricamente. </p><p class="mt-5"> Nivel lógico: Establece las equivalencias entre los valores eléctricos de las señales y sus valores lógicos. </p></div><div class="w-4/5"><img src="'+jc+'" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.5 Direccionamiento</h2><h3 class="flex justify-center text-3xl font-bold">1.2.5.1 Modo real</h3><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Este es un modo de operación específico en las CPUs x86 que se utiliza en el proceso de inicio de la computadora y la ejecución de sistemas operativos antiguos, como MS-DOS. La arquitectura 286 introdujo el modo protegido, permitiendo, entre otras cosas, la protección de la memoria a nivel de hardware. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.5.2 Modo protegido</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> El modo protegido tiene un número de nuevas características diseñadas para mejorar las multitareas y la estabilidad del sistema, como protección de memoria, y soporte de hardware para memoria virtual así como de conmutación de tareas. La mayoría de los sistemas operativos x86 modernos corren en modo protegido. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.5.3 Modo virtual</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> El modo virtual permite la ejecución de aplicaciones de modo real que violan las reglas bajo control de un sistema operativo de modo protegido. </p></div><div class="w-4/5 flex justify-center"><img src="'+Cc+'" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.6 Temporización</h2><h3 class="flex justify-center text-3xl font-bold">1.2.6.1 Reloj del sistema</h3><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> El reloj de una computadora se utiliza para dos funciones principales: </p><p class="mt-5"> 1. Para sincronizar las diversas operaciones que realizan los diferentes subcomponentes del sistema informático. </p><p class="mt-5"> 2. Para saber la hora. El reloj físicamente es un circuito integrado que emite una cantidad de pulsos por segundo, de manera constante. Al número de pulsos que emite el reloj cada segundo se llama Frecuencia del Reloj. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.6.2 Reset del sistema</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Se conoce como reset a la puesta en condiciones iniciales de un sistema. Este puede ser mecánico, electrónico o de otro tipo. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">1.2.6.3 Estado de espera</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Un estado de espera es una situación en la que el procesador de la computadora experimenta un retraso, principalmente cuando accede a la memoria externa o a un dispositivo que responde lentamente. </p></div></div></div></div>',1),Ac=[Rc];function Sc(e,t){return ot(),at("div",Pc,Ac)}const Oc=Pt(qc,[["render",Sc]]),Ic="/assets/procesador-03suZW_j.jpg",Mc="/assets/jerarquia-dQTiudHd.jpg",Tc="/assets/EJEMPLOCPU-biyrXwyl.jpg",Uc="/assets/ejmplocpu-HCZvrisJ.jpg",Lc="/assets/ciclofetch-VoFL9O4m.jpg",zc="/assets/casocpu-uYOINl2y.jpg",Dc={},Nc={class:"bg-gray-300 p-5"},Fc=qt('<div class="container mx-auto rounded-lg bg-white p-8"><div class="flex justify-center bg-black p-3 rounded"><h1 class="text-center text-4xl text-white font-medium">2. Estructura y funcionamiento de la CPU</h1></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.1 Organización del procesador</h2><div class="flex flex-row justify-center"><div class="w-4/5"><p>La Unidad de Procesamiento (CPU) controla el funcionamiento del computador y lleva a cabo sus funciones de procesamiento de datos. Frecuentemente se le llama procesador.</p><p>Un procesador lleva a cabo una gran variedad de:</p><p>Cálculos, Comparaciones numéricas y Transferencias de datos como respuesta a las peticiones de los programas que están siendo ejecutados en memoria.</p><p>La Unidad Central de Proceso está constituida internamente por: La Unidad de Control: La unidad de control le indica al resto del sistema como llevar a cabo las instrucciones de un programa. Comanda las señales electrónicas entre la memoria y la unidad aritmético-lógica</p><p>Unidad Aritmético-Lógica (ALU): Recibe los datos sobre los que efectúa operaciones de cálculo y comparaciones. Toma decisiones lógicas</p></div></div><div class="flex justify-center mt-5"><img src="'+Ic+'" alt=""></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.2 Estructura de registro</h2><div class="flex flex-row justify-center"><div class="w-4/5"><p>La estructura de registros en una CPU se refiere a la colección de registros de almacenamiento de datos que se utilizan internamente para llevar a cabo diversas operaciones. Estos registros son esenciales para el funcionamiento de la CPU, ya que almacenan datos que se están procesando en un momento dado. La cantidad y tipos de registros pueden variar según la arquitectura de la CPU.</p></div></div><div class="flex justify-center mt-5"><img src="'+Mc+'" alt=""></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.2.1 Registros visibles para el usuario</h2><div class="flex flex-row justify-center"><div class="w-4/5"><p>Son aquellos que pueden ser referenciado por medio del lenguaje maquina que ejecuta la CPU, los registro que normalmente disponibles son: Registros de propósito general, son aquellos que pueden guardar tanto datos como direcciones. Registro de datos, que pueden ser asignados por el programador a diversas funciones. En algunos casos son de propósito general y pueden ser empleados por cualquier instrucción de máquina que lleve a cabo operaciones sobre los datos.</p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.2.2 Registros de control y de estados</h2><div class="flex flex-row justify-center"><div class="w-4/5"><p>Son utilizados por la unidad de control para controlar el funcionamiento del procesador y por programas privilegiados del sistema operativo para controlar la ejecucion de programas. Registros de control y estado Hay diversos registros del procesador que se emplean para controlar su funcionamiento.</p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.2.3 Ejemplos de registros de CPU reales</h2><div class="flex flex-row justify-center"><div class="w-3/5 text-3xl"><p>Resulta instructivo examinar y comparar las organizaciones de registros de sistemas análogos. A continuación, se examinan dos microprocesadores de 16 bits diseñados aproximadamente al mismo tiempo: Por un lado esta el Motorola MC68000[STRI79] y el Intel 8086[MORS78]</p></div><div class="w-2/5"><img src="'+Tc+'" alt=""></div></div><div class="flex flex-row justify-center mt-5"><div class="w-4/5"><img src="'+Uc+'" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.3 Organización del procesador</h2><div class="flex flex-row justify-center"><div class="w-4/5 text-xl"><p>Es un término más general que se refiere al proceso completo que sigue una CPU para ejecutar un programa. Este proceso se divide en varias etapas fundamentales que se repiten continuamente mientras la computadora está en funcionamiento.</p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.3.1 Ciclo Fetch-Decode-Execute</h2><div class="flex flex-row justify-center"><div class="w-3/5"><p>Un ciclo de instrucción (también llamado ciclo de fetch-and-execute o ciclo de fetch-decode-execute en inglés) es el período que tarda la unidad central de proceso (CPU) en ejecutar una instrucción de lenguaje máquina. Comprende una secuencia de acciones determinada que debe llevar a cabo la CPU para ejecutar cada instrucción en un programa. Secuencia de acciones del ciclo de instrucción:</p><p class="mt-2 font-semibold">Buscar la instrucción en la memoria principal:</p><p>Se vuelca el valor del contador de programa sobre el bus de direcciones. Entonces la CPU pasa la instrucción de la memoria principal a través del bus de datos al Registro de Dirección de Memoria (MAR).</p><p class="mt-2 font-semibold">Decodificar la instrucción:</p><p>El decodificador de instrucción interpreta e implementa la instrucción. El registro de instrucción (IR) mantiene la instrucción en curso mientras el contador de programa (PC, program counter) guarda la dirección de memoria de la siguiente instrucción a ser ejecutada.</p><p class="mt-2 font-semibold">Ejecutar la instrucción:</p><p>A partir del registro de instrucción, los datos que forman la instrucción son decodificados por la unidad de control. Ésta interpreta la información como una secuencia de señales de control que son enviadas a las unidades funcionales relevantes de la CPU para realizar la operación requerida por la instrucción poder terminarla y seguir así.</p><p class="mt-2 font-semibold">Almacenar o guardar resultados:</p><p>El resultado generado por la operación es almacenado en la memoria principal o enviado a un dispositivo de salida dependiendo de la instrucción. Basándose en los resultados de la operación, el contador de programa se incrementa para apuntar a la siguiente instrucción o se actualiza con una dirección diferente donde la próxima instrucción será recogida.</p></div><div class="w-2/5"><img src="'+Lc+'" class="w-full" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.3.2 Segmentación de Instrucciones</h2><div class="flex flex-row justify-center"><div class="w-4/5 text-lg"><p>La segmentación de instrucciones Es una técnica que permite implementar el paralelismo a nivel de instrucción en un único procesador.</p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.3.3 Conjunto de instrucciones: Características y funciones</h2><div class="flex flex-row justify-center"><div class="w-4/5 text-lg"><p>Los conjuntos de instrucciones de las máquinas deben tender a poseer una serie de propiedades, bastante ideales e imprecisas, que pueden resumirse en las siguientes: El conjunto de instrucciones de un computador debe ser completo en el sentido de que se pueda construir un programa para evaluar una función computable usando una cantidad de memoria razonable y empleando un tiempo moderado, es decir, el número de instrucciones de ese programa no debe ser demasiado elevado</p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.3.4 Modos de Direccionamiento.</h2><div class="flex flex-row justify-center"><div class="w-4/5 text-xl"><p class="mt-2 font-semibold">1.-Direccionamiento por registro:</p><p>Los operandos son registros. Los datos a operar están contenidos en dos registros de 32 bits y el resultado será colocado en otro registro, del mismo tamaño.</p><p class="mt-2 font-semibold">2.- Direccionamiento base o desplazamiento:</p><p>Uno de los operandos está en una localidad de memoria cuya dirección es la suma de un registro y una constante que forma parte de la misma instrucción.</p><p class="mt-2 font-semibold">3.- Direccionamiento inmediato:</p><p>Donde uno de los operandos es una constante que está en la misma instrucción.</p><p class="mt-2 font-semibold">4.- Direccionamiento relativo al PC:</p><p>Se forma una dirección sumando una constante, que está en la instrucción, con el registro PC. El resultado de la suma corresponde a la dirección destino si un brinco condicional se va a realizar.</p><p class="mt-2 font-semibold">5.- Direccionamiento pseudo directo:</p><p>La dirección destino de un salto corresponde a la concentración de 26 bits que están en la misma instrucción con los bits más significativos del PC.</p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">2.4 Casos de Estudio Reales</h2><div class="flex flex-row justify-center mt-3"><div class="w-3/5 text-xl"><p class="mt-2 font-semibold">I-8086</p><p>Los modos de direccionamiento del 8086 son muy irregulares. Los registros del procesador, se usan para contener los datos con que se está trabajando puesto que el acceso a los registros es mucho más rápido que los accesos a memoria.</p></div><div class="w-2/5"><img src="'+zc+'" class="w-full" alt=""></div></div></div></div>',1),$c=[Fc];function Hc(e,t){return ot(),at("div",Nc,$c)}const Bc=Pt(Dc,[["render",Hc]]),kc="/assets/chip1-F7Jve9XM.png",Kc="/assets/chip2-W-6-n0BM.png",Wc="/assets/arquitectura--r7s0wV1.png",Vc="/assets/bus-SAjITyHX.png",Qc="/assets/ports-_7zrY_or.png",Xc="/assets/dmapio-s0QzADeo.png",Jc="/assets/tarjetagrafica-NexwJVSw.png",Yc="/assets/gamabaja-yoApMGOu.png",Zc="/assets/gamamedia1-f_hsxnwm.png",Gc="/assets/gamaalta1-WFn8hmVC.png",ed="/assets/gamaalta2--fCOHDk7.png",td="/assets/perentrada-0ZCVTH9d.png",sd="/assets/persalida-uNIQOnkl.png",nd="/assets/fuentealim1-60KYdxDi.png",od="/assets/fuentealim2-RXPTzWGj.png",ad="/assets/ambienteservicio-lBCoyDll.png",id={},rd={class:"bg-gray-300 p-5"},ld=qt('<div class="container mx-auto rounded-lg bg-white p-5"><div class="flex justify-center bg-black p-3 rounded"><h1 class="text-center text-4xl text-white font-medium">3. Selección de Componentes para ensamble de equipo de Computo</h1></div><div class="container mx-auto mt-5"><h2 class="flex justify-center text-3xl font-bold">3.1 Chipset</h2><div class="flex flex-row justify-evenly mt-3"><div class="w-2/5"><h3 class="text-xl font-semibold">Definicion</h3><p> Un chipset es el conjunto de circuitos integrados diseñados con base en la arquitectura de un procesador (en algunos casos, diseñados como parte integral de esa arquitectura), permitiendo que ese tipo de procesadores funcionen en una placa base. Sirven de puente de comunicación con el resto de componentes de la placa, como son la memoria, las tarjetas de expansión, los puertos USB, ratón, teclado, etc. </p><div class="flex flex-row mt-3"><div><img src="'+kc+'" alt="" srcset=""></div><div><img src="'+Kc+'" alt="" srcset=""></div></div></div><div class="w-2/5"><h3 class="text-xl font-semibold text-center">Funcionamiento</h3><p class="text-xl"> El chipset es quien hace posible que la placa base funcione como eje del sistema, dando soporte a varios componentes e interconectándolos de forma que se comuniquen entre ellos haciendo uso de diversos buses. Es uno de los pocos elementos que tiene conexión directa con el procesador. Gestiona la mayor parte de la información que entra y sale del bus principal, del sistema de video y muchas veces de la memoria RAM. Esquema de arquitectura abierta que establece modularidad: el chipset debe tener interfaces estándar para los demás dispositivos. </p></div></div><div class="flex flex-row justify-evenly mt-20"><div class="w-1/5"><h3 class="text-xl font-semibold">Northbridge</h3><p class="text-2xl"> Se usa como puente de enlace entre el microprocesador y la memoria. Controla las funciones de acceso hacia y entre el microprocesador, la memoria RAM, el puerto gráfico AGP o el PCI-Express de gráficos, y las comunicaciones con el puente sur. </p></div><div class="w-1/3"><img src="'+Wc+'" alt="" srcset=""></div><div class="w-1/5"><h3 class="text-xl font-semibold">Southbridge</h3><p class="text-2xl"> Controla los dispositivos asociados como son la controladora de discos IDE, puertos USB, SATA, RAID, puertos infrarrojos, disquetera, LAN y una larga lista de todos los elementos que podamos imaginar integrados en la placa madre. Es el encargado de comunicar el procesador con el resto de los periféricos. </p></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.1.1. Unidad de Control de Procesamiento(CPU)</h2><div class="flex flex-row justify-evenly mt-5"><div class="w-2/5"><h3 class="text-xl font-semibold">Definicion</h3><p class="text-lg"> La unidad central de procesamiento (siglas en inglés Central Processing Unit) es el hardware dentro de una computadora u otros dispositivos programables. Su trabajo es interpretar las instrucciones de un programa informático mediante la realización de las operaciones básicas aritméticas, lógicas y externas (provenientes de la unidad de entrada/salida). Su diseño y avance ha variado notablemente desde su creación, aumentando su eficiencia y potencia, y reduciendo aspectos como el consumo de energía y el costo. </p></div><div class="w-2/5"><h3 class="text-xl font-semibold text-center">Componentes</h3><ul><li><p class="font-semibold"> Unidad Aritmético Lógica(ALU):</p> Realiza operaciones matemáticas y lógicas. </li><li><p class="font-semibold"> Unidad de Control(CU):</p> Dirige el tráfico de información entre los registros del CPU y conecta con la ALU las instrucciones extraídas de la memoria. </li><li><p class="font-semibold">Registros Internos:</p> No accesibles(de instrucción, bus de datos y bus de dirección) </li><li> Accesibles de uso específico(contador programa, puntero pila, flags,etc) o uso general. </li></ul></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.1.2 Controladores de bus</h2><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><ul class="text-3xl"><li class="mt-1">El controlador de bus se encarga de la frecuencia de funcionamiento y las señales de sincronismo, temporización y control. Está ubicado en un chip de la placa base. </li><li class="mt-2">Es la vía a través de la cual se van a enviar y recibir todas las comunicaciones (internas y externas) del sistema informático. </li><li class="mt-2">El bus solamente es un dispositivo de transferencia de información. </li></ul></div><div class="w-2/5"><img src="'+Vc+'" alt="" srcset=""></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.1.3 Módulos de entrada/salida</h2><div class="flex flex-row justify-evenly mt-5 text-xl"><div class="w-1/5"><ul><li class="mt-2">Un puerto E/S es un enchufe en una computadora al que se conecta un cable. </li><li class="mt-2">El puerto conecta la CPU a un dispositivo periférico a través de una interfaz ya se de hardware o una red. </li><li class="mt-2">Es un punto de conexión que actúa como interfaz entre la computadora y dispositivos externos. </li><li class="mt-2">Hay dos tipos de puertos: Internos y Externos. </li></ul></div><div class="w-1/5"><h2 class="text-center font-semibold">Puertos</h2><ul><li class="mt-2">PUERTO SERIAL </li><li class="mt-2">PUERTO PARALELO </li><li class="mt-2">PUERTO USB </li><li class="mt-2">PUERTO PS/2 </li><li class="mt-2">PUERTO DE INFRARROJOS </li><li class="mt-2">PUERTO BLUETOOTH </li><li class="mt-2">PUERTO FIREWIRE </li></ul></div><div class="w-1/3"><img src="'+Qc+'" alt="" srcset=""></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.1.4 Controlador de Interruptores</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p>El controlador de interrupciones es un módulo que tiene por función gestionar las interrupciones de entrada/salida para el procesador. Esto ahorra diseñar lógica y añadir patitas al procesador. También proporciona flexibilidad porque permite idealmente, gestionar un número ilimitado señales de interrupción (favoreciendo la expansión del sistema de entrada/salida). El controlador recibe el conjunto de señales de interrupción procedentes de los dispositivos, toma la decisión de cuál es la más prioritaria, y envía una única señal al procesador. La respuesta del procesador es transmitida al dispositivo y el propio controlador se encarga de depositar en el bus el vector de la interrupción. </p></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.1.5 Controlador de Acceso Directo a Memoria (DMA)</h2><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><p class="text-xl"> El mecanismo de acceso directo a memoria está controlado por un chip específico, el DMAC (&quot;DMA Controller&quot;), que permite realizar estos intercambios sin apenas intervención del procesador. En los XT estaba integrado en un chip 8237A que proporcionaba 4 canales de 8 bits (puede mover solo 1 Byte cada vez); sus direcciones de puerto son 000–00Fh. Posteriormente en los AT se instalaron dos de estos integrados y las correspondientes líneas auxiliares en el bus de control. </p></div><div class="w-2/5"><img src="'+Xc+'" alt="" srcset=""></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.1.6 Circuitos de Temporización</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> El circuito electrónico que más se utiliza tanto en la industria como en circuitería comercial, es el circuito temporizador o de retardo, dentro de la categoría de temporizadores, cabe destacar el más económico y también menos preciso consistente en una resistencia y un condensador, a partir de aquí se puede contar con un sinfín de opciones. </p><p class="mt-5"> Un temporizador básicamente consiste en un elemento que se activa o desactiva después de un tiempo preestablecido. De esta manera podemos determinar el parámetro relacionado con el tiempo que ha de transcurrir para que el circuito susceptible de temporizarse, se detenga o empiece a funcionar o simplemente cierre un contacto o lo abra. </p></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.1.7 Circuitos de Control</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Es una red secuencial que acepta un código que define la operación que se va a ejecutar y luego prosigue a través de una secuencia de estados, generando una correspondiente secuencia de señales control. </p><p class="mt-5"> Estas señales de control incluyen el control de lectura-escritura y señales de dirección de memoria válida en el bus de control del sistema. Otras señales generadas por el controlador se conectan a la ALU y a los registros internos del procesador para regular el flujo de información en el procesador y desde los buses de dirección y de datos del sistema. </p></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.1.8 Controladores de Video</h2><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><img src="'+Jc+'" alt="" srcset=""></div><div class="w-2/5"><p class="text-xl"> La tarjeta de video, (también llamada controlador de video), es un componente electrónico requerido para generar una señal de video que se manda a una pantalla de video por medio de un cable. La tarjeta de video se encuentra normalmente en la placa de sistema de la computadora o en una placa de expansión. La tarjeta gráfica reúne toda la información que debe visualizarse en pantalla y actúa como interfaz entre el procesador y el monitor; la información es enviada a éste por la placa luego de haberla recibido a través del sistema de buses. </p></div></div><div class="flex flex-row justify-center mt-3"><p class="w-4/5 text-lg"> Una tarjeta gráfica se compone, básicamente, de un controlador de video, de la memoria de pantalla o RAM video, y el generador de caracteres, y en la actualidad también poseen un acelerador de gráficos. El controlador de video va leyendo a intervalos la información almacenada en la RAM video y la transfiere al monitor en forma de señal de video; el número de veces por segundo que el contenido de la RAM video es leído y transmitido al monitor en forma de señal de video se conoce como frecuencia de refresco de la pantalla. </p></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-4xl font-bold">Gamas</h2><div class="mt-10"><h2 class="flex justify-start text-2xl font-semibold">Gama baja</h2><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><h3 class="text-xl font-semibold">Tarjetas</h3><ul><li class="mt-2"> Son las más económicas y suelen tener características limitadas. </li><li class="mt-2"> Son adecuadas para sistemas básicos o de oficina. </li><li class="mt-2"> Pueden no ser compatibles con hardware de alto rendimiento, como tarjetas gráficas dedicadas de gama alta. </li></ul></div><div class="w-2/5"><h3 class="text-xl font-semibold">Computadoras</h3><ul><li class="mt-2"> Están diseñadas para tareas sencillas y no requieren un alto rendimiento. </li><li class="mt-2"> Son ideales para usuarios con presupuestos ajustados que solo necesitan un equipo básico. </li><li class="mt-2"> No son adecuadas para juegos intensivos o aplicaciones de uso intensivo del procesador. </li></ul></div></div><div class="flex justify-center"><img src="'+Yc+'" alt="" srcset=""></div></div><div class="mt-10"><h2 class="flex justify-start text-2xl font-semibold">Gama Media</h2><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><h3 class="text-xl font-semibold">Tarjetas</h3><ul><li class="mt-2"> Equilibrio entre precio y rendimiento. </li><li class="mt-2"> Adecuadas para la mayoría de los usuarios que no necesitan características extremas. </li><li class="mt-2"> Admiten hardware de gama media, como procesadores de nivel intermedio y tarjetas gráficas. </li><li class="mt-2"> Tienen conectividad y características suficientes para la mayoría de las necesidades de los usuarios. </li></ul></div><div class="w-2/5"><h3 class="text-xl font-semibold">Computadoras</h3><ul><li class="mt-2"> Ideales para tareas cotidianas, como navegación web, procesamiento de documentos, reproducción de contenido multimedia y juegos ligeros. </li><li class="mt-2"> Suelen tener componentes equilibrados en términos de rendimiento y precio. </li><li class="mt-2"> A menudo son más asequibles que las de gama alta y ofrecen un buen valor. </li></ul></div></div><div class="flex justify-center"><img src="'+Zc+'" alt="" srcset=""></div></div><div class="mt-10"><h2 class="flex justify-start text-2xl font-semibold">Gama Alta</h2><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><h3 class="text-xl font-semibold">Tarjetas</h3><ul><li class="mt-2"> Suelen estar equipadas con las últimas tecnologías y características de vanguardia. Pueden admitir múltiples tarjetas gráficas (SLI o CrossFire), múltiples unidades de almacenamiento de alta velocidad y una amplia gama de puertos y conectividad. </li><li class="mt-2"> Ideales para profesionistas que necesitan un rendimiento extremo. </li><li class="mt-2"> Ofrecen una alta calidad de construcción y componentes duraderos. </li></ul></div><div class="w-2/5"><h3 class="text-xl font-semibold">Computadoras</h3><ul><li class="mt-2"> Procesadores de alto rendimiento, tarjetas gráficas de gama alta, grandes cantidades de RAM y unidades de estado sólido (SSD) de alta capacidad. </li><li class="mt-2"> Son adecuadas para juegos intensivos, edición de video, diseño gráfico y otras tareas exigentes. </li><li class="mt-2"> Suelen tener una construcción robusta y una estética premium. </li></ul></div></div><div class="flex flex-row justify-around"><img src="'+Gc+'" alt="" srcset=""><img src="'+ed+'" alt="" srcset=""></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.2. APLICACIONES</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> El Chipset es el que hace posible que la placa base funcione como eje del sistema, dando soporte a varios componentes e interconectándolos de forma que se comuniquen entre ellos haciendo uso de diversos buses. </p><p class="mt-5"> Es uno de los pocos elementos que tiene conexión directa con el procesador, gestiona la mayor parte de la información que entra y sale por el bus principal del procesador. </p><p class="mt-5"> En el caso de los computadores PC, es un esquema de arquitectura abierta que establece modularidad: el Chipset debe tener interfaces estándar para los demás dispositivos. </p></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.2.1 Entrada/Salida</h2><div class="flex flex-row justify-center mt-5 text-xl"><div class="w-4/5"><p class="mt-5"> Los dispositivos periféricos de la computadora tienen un papel que es esencial ya que sin tales dispositivos esta no sería totalmente útil. </p><p class="mt-5"> A través de estos dispositivos podemos introducir a la computadora datos que nos sean útiles para la resolución de algún problema y por consiguiente obtener el resultado de dichas operaciones, es decir, poder comunicarnos con la computadora. </p><p class="mt-5"> La computadora necesita de entradas para poder generar una salida y estas se dan a través de dos dispositivos perifericos ya existentes. </p></div></div><div class="mt-10"><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><h3 class="text-2xl font-semibold">Dispositivos Perifericos de Entrada</h3><p class="text-xl"> Aquellos que se utilizan para proporcionar datos y señales a la unidad de procesamiento.Suele hacerse una clasificación de acuerdo a la modalidad de entrada. </p></div><div class="w-2/5"><h3 class="text-2xl font-semibold">Dispositivos Perifericos de Salida</h3><p class="text-xl">Son capaces de reproducir lo que ocurre en la computadora para el interés del usuario. La CPU genera patrones de bits internos y son estos dispositivos los encargados de hacerlos comprensibles para el usuario </p></div></div><div class="flex flex-row justify-around mt-3"><img src="'+td+'" alt="" srcset=""><img src="'+sd+'" alt="" srcset=""></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.2.2. Almacenamiento</h2><div class="flex flex-row justify-center mt-5 text-2xl"><div class="w-4/5"><p class="mt-5"> Conforme la tecnología avanza, más datos se van generando, por lo que es necesario contar con un almacenamiento eficiente para poder guardar toda esa información y acceder a ellos. </p><p class="mt-5"> El almacenamiento de datos tiene un proceso a través del uso de la tecnología, ésta se aplica para organizar, distribuir y archivar información con los bytes y los bits que son parte de los sistemas de los que la gente depende día con día, llega a ser tan importante en todos los servicios. </p></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.2.3 Fuentes de alimentación</h2><div class="flex flex-row justify-center mt-5 text-2xl"><div class="w-3/5"><p class="mt-5"> Es un dispositivo que se monta en el gabinete de la computadora y que se encarga básicamente de transformar la corriente alterna de la línea eléctrica comercial en corriente directa; la cuál es utilizada por los elementos electrónicos y eléctricos de la computadora. Otras funciones son las de suministrar la cantidad de corriente y voltaje que los dispositivos requieren así como protegerlos de subidas de problemas en el suministro eléctrico como subidas de voltaje. </p><p class="mt-5 font-semibold"> FUENTE DE PODER AT </p><p>AT son las siglas de (&quot;Advanced Technology&quot;) ó tecnología avanzada, que se refiere a un estándar de dispositivos introducidos al mercado a inicios de los años 80´s que reemplazo a una tecnología denominada XT (&quot;eXtended Technology&quot;) ó tecnología extendida. </p><p class="mt-5 font-semibold">FUENTE DE PODER ATX </p><p> ATX son las siglas de (&quot;Advanced Technology eXtended&quot;) ó tecnología avanzada extendida, que es una segunda generación de fuentes de alimentación introducidas al mercado para computadoras con microprocesador Intel® Pentium MMX, y a partir de ese momento, se extiende su uso. La serie MVP es la familia más versátil de fuentes de alimentación de potencia media que utiliza componentes magnéticos de SMD y convertidos DC-DC internos, combinados con módulos PFC, que pueden ser configurables desde 1 hasta 10 tensiones de salida con valores entre 2 y 60 v. tiene todas las homologaciones de seguridad necesarias y es un producto marcado “CE”. </p></div><div class="w-2/5"><img src="'+nd+'" alt="" srcset=""><img src="'+od+'" alt="" srcset=""></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.3. Ambientes de Servicio</h2><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><img src="'+ad+'" alt="" srcset=""></div><div class="w-2/5"><p class="text-2xl"> El negocio de proveer servicios de datos es mucho más complejo que la forma en la que se dan los tradicionales servicios, los primeros requieren de nuevos conocimientos y modelos de negocio, que con frecuencia se termina involucrando o necesitando la colaboración de terceras empresas. Por lo que se hace necesario que los operadores tradicionales transformen su negocio para ofrecer los servicios de datos con los niveles de servicio que el mercado exige. </p></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.3.1 Negocios</h2><div class="flex flex-row justify-center mt-5 text-2xl"><div class="w-4/5"><p class="mt-3"> Definitivamente, la tecnología en general ha sido la causa principal y la acción más directa para la transformación del trabajo de las organizaciones en la posguerra del siglo XX. Tanto los bienes de capital &quot;duros&quot; (computadores, teléfonos, videos, facsímiles, grabadoras, etc.), como los programas y sistemas de información y comunicación en general, han incrementado enormemente la productividad y eficiencia de las organizaciones. </p></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.3.2 Industria</h2><div class="flex flex-row justify-center mt-5 text-2xl"><div class="w-4/5"><p class="mt-2"> La industrialización de los servicios de TI va a redefinir el mercado en términos de como las organizaciones evalúan, compran y seleccionan los servicios y como los vendedores desarrollan y establecen precios de los servicios. </p><p class="mt-2"> Para lograr esta estandarización, se requiere un enfoque hacia las soluciones genéricas y esto debe ser responsabilidad de los proveedores, que deben de desarrollar, operar y administrar el resultado de estos genéricos de TI </p><p class="mt-2"> Aunque los servicios de TI están en proceso de madurez, la madurez de la industria se ha incrementado en aspectos evidentes, como la forma en que los servicios son implementados y administrados. </p></div></div></div><div class="container mx-auto mt-20"><h2 class="flex justify-center text-3xl font-bold">3.3.3 Comercio Electrónico</h2><div class="flex flex-row justify-center mt-5 text-2xl"><div class="w-4/5"><p class="mt-2"> El desarrollo de nuevas tecnologías y de telecomunicaciones ha hecho que los intercambios de datos crezcan a niveles extraordinarios, simplificándose cada vez más y creando nuevas formas de comercio, y en este marco se desarrolla el Comercio Electrónico. </p><p class="mt-2"> Se considera “Comercio Electrónico” al conjunto de aquellas transacciones comerciales y financieras realizadas a través del procesamiento y la transmisión de información, incluyendo texto, sonido e imagen. </p></div></div></div></div>',1),cd=[ld];function dd(e,t){return ot(),at("div",rd,cd)}const ud=Pt(id,[["render",dd]]),fd="/assets/memoriaram--5DCgQ3l.jpg",pd="/assets/ciclocompartido-IW3J9INS.jpeg",md="/assets/Redes-Jerárquicas-mchjcAUF.png",hd={},vd={class:"bg-gray-300 p-5"},gd=qt('<div class="container mx-auto rounded-lg bg-white p-5"><div class="flex justify-center bg-black p-3 rounded"><h1 class="text-center text-4xl text-white font-medium">4. ASPECTOS BASICOS DE LA COMPUTACION PARALELA</h1></div><div class="container mx-auto mt-5"><div class="flex flex-row justify-evenly mt-3"><div class="w-2/5 text-xl"><p class="mt-2">La computación paralela es una forma de cómputo en la que muchas instrucciones se ejecutan simultáneamente, operando sobre el principio de problemas grandes, a menudo se pueden dividir en unos más pequeños, que luego son resueltos simultáneamente (en paralelo). </p><p class="mt-2"> Los programas informáticos paralelos son más difíciles de escribir que los secuenciales, porque la concurrencia introduce nuevos tipos de errores de software, siendo las condiciones de carrera los más comunes. </p></div><div class="w-2/5"><h3>Hay varias formas diferentes de computación paralela:</h3><ul class="mt-3"><li class="mt-2"><p class="font-bold">Paralelismo a nivel de bit:</p> Se refiere a aumentar el tamaño de la palabra del procesador para reducir el número de instrucciones que debe ejecutar el procesador en variables cuyos tamaños sean mayores a la longitud de la cadena </li><li class="mt-2"><p class="font-bold">Paralelismo a nivel de instrucción:</p> se refiere a la capacidad de los procesadores para reordenar y combinar grupos de instrucciones que luego son ejecutadas en paralelo sin cambiar el resultado del programa. </li><li class="mt-2"><p class="font-bold">Paralelismo de datos:</p> se refiere a la capacidad de los procesadores para procesar múltiples datos al mismo tiempo. </li><li class="mt-2"><p class="font-bold">Paralelismo de tareas:</p> se refiere a la capacidad de los procesadores para realizar múltiples tareas al mismo tiempo</li></ul></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">Modelos de consistencia</h2><div class="mt-10"><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><h3 class="text-xl font-semibold">Single Instruction, Single Data (SISD)</h3><p>Hay un elemento de procesamiento, que tiene acceso a un único programa y a un almacenamiento de datos. En cada paso, el elemento de procesamiento carga una instrucción y la información correspondiente y ejecuta esta instrucción. El resultado es guardado de vuelta en el almacenamiento de datos. Luego SISD es el computador secuencial convencional, de acuerdo al modelo de von Neumann. </p></div><div class="w-2/5"><h3 class="text-xl font-semibold">Multiple Instruction, Single Data (MISD)</h3><p>Hay múltiples elementos de procesamiento, en el que cada cual tiene memoria privada del programa, pero se tiene acceso común a una memoria global de información. En cada paso, cada elemento de procesamiento de obtiene la misma información de la memoria y carga una instrucción de la memoria privada del programa. Este modelo es muy restrictivo y no se ha usado en ningún computador de tipo comercial. </p></div></div><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><h3 class="text-xl font-semibold">Single Instruction, Multiple Data (SIMD)</h3><p>Hay múltiples elementos de procesamiento, en el que cada cual tiene acceso privado a la memoria de información (compartida o distribuida). Sin embargo, hay una sola memoria de programa, desde la cual una unidad de procesamiento especial obtiene y despacha instrucciones. </p></div><div class="w-2/5"><h3 class="text-xl font-semibold">Multiple Instruction, Multiple Data (MIMD)</h3><p>Hay múltiples unidades de procesamiento, en la cual cada una tiene tanto instrucciones como información separada. Cada elemento ejecuta una instrucción distinta en un elemento de información distinto. Los elementos de proceso trabajan asíncronamente. Los clusters son ejemplo son ejemplos del modelo MIMD. </p></div></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.2 TIPOS DE COMPUTACIÓN PARALELA</h2><div class="mt-10"><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><h3 class="text-xl font-semibold">Paralelismo a nivel de bit</h3><p>Históricamente, los microprocesadores de 4 bits fueron sustituidos por unos de 8 bits, luego de 16 bits y 32 bits, esta tendencia general llegó a su fin con la introducción de procesadores de 64 bits, lo que ha sido un estándar en la computación de propósito general durante la última década. </p></div><div class="w-2/5"><h3 class="text-xl font-semibold">Paralelismo a nivel de instrucción</h3><p>Los procesadores modernos tienen &#39;&#39;pipeline&#39;&#39; de instrucciones de varias etapas. Cada etapa en el pipeline corresponde a una acción diferente que el procesador realiza en la instrucción correspondiente a la etapa; un procesador con un pipeline de N etapas puede tener hasta n instrucciones diferentes en diferentes etapas de finalización </p></div></div><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><h3 class="text-xl font-semibold">Paralelismo de datos</h3><p>El paralelismo de datos es el paralelismo inherente en programas con ciclos, que se centra en la distribución de los datos entre los diferentes nodos computacionales que deben tratarse en paralelo. Muchas de las aplicaciones científicas y de ingeniería muestran paralelismo de datos </p></div><div class="w-2/5"><h3 class="text-xl font-semibold">Paralelismo de tareas</h3><p>Es un paradigma de la programación concurrente que consiste en asignar distintas tareas a cada uno de los procesadores de un sistema de cómputo. En consecuencia, cada procesador efectuará su propia secuencia de operaciones. En su modo más general, el paralelismo de tareas se representa mediante un grafo de tareas, el cual es subdividido en subgrafos que son luego asignados a diferentes procesadores. </p></div></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.2.1 CLASIFICACIÓN</h2><div class="flex flex-row justify-center mt-5 text-2xl"><div class="w-4/5"><p class="mt-2"> Las computadoras paralelas se pueden clasificar de acuerdo con el nivel en el que el hardware soporta paralelismo. Esta clasificación es análoga a la distancia entre los nodos básicos de cómputo. </p><p class="mt-2"><p class="font-bold">Computación multinúcleo:</p> un procesador multinúcleo es un procesador que incluye múltiples unidades de ejecución (núcleos) en el mismo chip. </p><p class="mt-2"><p class="font-bold">Multiprocesamiento simétrico:</p> un multiprocesador simétrico (SMP) es un sistema computacional con múltiples procesadores idénticos que comparten memoria y se conectan a través de un bus. </p><p class="mt-2"><p class="font-bold">Computación en clúster:</p> un clúster es un grupo de ordenadores débilmente acoplados que trabajan en estrecha colaboración, de modo que en algunos aspectos pueden considerarse como un solo equipo. </p><p class="mt-2"><p class="font-bold">Procesamiento paralelo masivo:</p> tienden a ser más grandes que los clústeres, con «mucho más» de 100 procesadores. </p><p class="mt-2"><p class="font-bold">Computación distribuida:</p> la computación distribuida es la forma más distribuida de la computación paralela. Se hace uso de ordenadores que se comunican a través de la Internet para trabajar en un problema dado. </p><p class="mt-2"><p class="font-bold">Circuitos integrados de aplicación específica:</p> debido a que un ASIC (por definición) es específico para una aplicación dada, puede ser completamente optimizado para esa aplicación. </p><p class="mt-2"><p class="font-bold">Procesadores vectoriales:</p> pueden ejecutar la misma instrucción en grandes conjuntos de datos. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.2.2 ARQUITECTURA DE COMPUTADORAS SECUENCIALES</h2><div class="flex flex-row justify-around mt-5"><div class="w-2/5"><h3 class="text-xl font-semibold">Circuitos secuenciales asíncronos</h3><p>En circuitos secuenciales asíncronos los cambios de estados ocurren al ritmo natural asociado a las compuertas lógicas utilizadas en su implementación, lo que produce retardos en cascadas entre los biestables del circuito, es decir no utilizan elementos especiales de memoria. </p></div><div class="w-2/5"><h3 class="text-xl font-semibold">Circuitos secuenciales síncronos</h3><p>Los circuitos secuenciales síncronos solo permiten un cambio de estado en los instantes marcados o autorizados por una señal de sincronismo de tipo oscilatorio denominada reloj (cristal o circuito capaz de producir una serie de pulsos regulares en el tiempo). </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.2.3 ORGANIZACIÓN DE DIRECCIONES DE MEMORIA</h2><div class="flex flex-row justify-around mt-5"><div class="w-4/5"><p class="text-lg">La memoria principal en un ordenador en paralelo puede ser compartida —compartida entre todos los elementos de procesamiento en un único espacio de direcciones—, o distribuida — cada elemento de procesamiento tiene su propio espacio local de direcciones—.El término memoria distribuida se refiere al hecho de que la memoria se distribuye lógicamente, pero a menudo implica que también se distribuyen físicamente. </p></div></div><div class="flex flex-row justify-around mt-5"><img src="'+fd+'" alt=""></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.3 SISTEMAS DE MEMORIA COMPARTIDA</h2><div class="flex flex-row justify-around mt-5"><div class="w-4/5"><p class="text-lg">Los sistemas de memoria compartida son aquellos en los que múltiples unidades de procesamiento comparten un espacio de direcciones de memoria común. Esto permite a los procesos comunicarse y compartir datos a través de la memoria compartida, lo que simplifica la programación paralela. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.3.1 Redes de Interconexión Dinámicas ó Indirectas</h2><div class="flex flex-row justify-around mt-5"><div class="w-4/5"><p class="text-lg">En el contexto de la arquitectura de computadoras, las redes de interconexión dinámicas o indirectas se refieren a los esquemas utilizados para conectar y comunicar los componentes de un sistema computacional, como procesadores, memoria y dispositivos de entrada/salida. Estas redes proporcionan una forma flexible y eficiente de transferir datos entre los distintos elementos del sistema. </p><p class="text-lg">Un ejemplo común de una red de interconexión dinámica en arquitectura de computadoras es el sistema de interconexión utilizado en los supercomputadores. Estos sistemas están diseñados para realizar tareas computacionalmente intensivas y requieren una alta capacidad de procesamiento y comunicación entre los nodos </p><p class="text-lg">En lugar de utilizar una arquitectura de bus tradicional, donde todos los componentes están conectados directamente a un único bus compartido, los supercomputadores suelen emplear arquitecturas de red más complejas. Estas arquitecturas utilizan enlaces de comunicación de alta velocidad, como redes toroidales, redes en malla o redes hipercúbicas, para interconectar los nodos de procesamiento y almacenamiento. </p><p class="text-lg">En una red de interconexión dinámica, los nodos pueden comunicarse indirectamente mediante saltos a través de otros nodos intermedios. Esto permite una comunicación eficiente y escalable en sistemas con un gran número de componentes. Además, estas redes suelen ser adaptables, lo que significa que pueden reconfigurarse dinámicamente para adaptarse a cambios en la carga de trabajo o a fallos en los nodos. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.3.1.1 Redes de Medio Compartido</h2><div class="flex mt-5"><p class="text-lg"> Es un tipo de arquitectura de red en la que múltiples dispositivos comparten un medio de comunicación común para enviar y recibir datos. En esta arquitectura, los dispositivos se conectan físicamente al mismo medio de transmisión, como un cable o una línea de transmisión, y deben coordinarse para acceder al medio y transmitir sus datos. </p><p class="text-lg"> Un ejemplo común de una red de medio compartido en arquitectura de computadoras es Ethernet, que utiliza un cable compartido o un segmento de red para conectar múltiples dispositivos, como computadoras, servidores o impresoras. En Ethernet, los dispositivos utilizan un protocolo llamado CSMA/CD (Acceso Múltiple por Detección de Portadora con Detección de Colisiones) para gestionar el acceso al medio compartido. </p></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">Protocolo de transferencia de ciclo partido</h2><div class="flex justify-around mt-5"><p class="text-lg w-2/5"> La operación de lectura se divide en dos transacciones no continuas de acceso al bus. La primera es de petición de lectura que realiza el máster (procesador) sobre el slave (memoria). Una vez realizada la petición el máster abandona el bus. Cuando el slave dispone del dato leído, inicia un ciclo de bus actuando como máster para enviar el dato al antiguo máster, que ahora actúa como slave. </p><img src="'+pd+'" class="w-2/5" alt=""></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.3.1.2 Redes conmutadas</h2><div class="flex flex-row justify-center mt-5 text-2xl"><div class="w-4/5"><div><p>CONEXIÓN POR CONMUTADORES CROSSBAR</p><p>Cada procesador (Pi) y cada módulo de memoria (Mi) tienen su propio bus. Existe un conmutador (S) en los puntos de intersección que permite conectar un bus de memoria con un bus de procesador. Para evitar conflictos cuando más de un procesador pretende acceder al mismo módulo de memoria se establece un orden de prioridad. Se trata de una red sin bloqueo con una conectividad completa pero de alta complejidad. </p></div><div class="mt-5"><p>CONEXIÓN POR RED MULTIETAPA</p><p> Representan una alternativa intermedia de conexión entre el bus y el crossbar. - Es de menor complejidad que el crossbar pero mayor que el bus simple. - La conectividad es mayor que la del bus simple pero menor que la del crossbar. - Se compone de varias etapas alternativas de conmutadores simples y redes de interconexión. </p></div></div><div class="w-4/5 flex justify-center"><img src="'+md+'" alt=""></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.4 SISTEMAS DE MEMORIA DISTRIBUIDA: MULTIPROCESADORES</h2><div class="flex mt-5"><div class="w-4/5"><p class="text-lg">Los sistemas de memoria distribuida o multicomputadores pueden ser de dos tipos básicos. El primer de ellos consta de un único computador con múltiples CPUs comunicadas por un bus de datos mientras que en el segundo se utilizan múltiples computadores, cada uno con su propio procesador, enlazados por una red de interconexión más o menos rápida. </p></div><div class="w-4/5"><p class="text-lg"> Sobre los sistemas de multicomputadores de memoria distribuida, se simula memorias compartidas. Se usan los mecanismos de comunicación y sincronización de sistemas multiprocesadores </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.4.1 Red de interconexión estática</h2><div class="flex justify-center"><div class="w-4/5 text-xl"><p>Los multicomputadores utilizan redes estáticas con enlaces directos entre nodos. Cuando un nodo recibe un mensaje lo procesa si viene dirigido a dicho nodo. Si el mensaje no va dirigido al nodo receptor lo reenvía a otro por alguno de sus enlaces de salida siguiendo un protocolo de encaminamiento. </p></div></div></div><div class="container mx-auto mt-10"><h2 class="flex justify-center text-3xl font-bold">4.5 casos de estudio</h2><div class="flex justify-center"><div class="w-4/5 text-xl"><p>Por numerosos motivos, el procesamiento distribuido se ha convertido en un área de gran importancia e interés dentro de la ciencia de la computación, produciendo profundas transformaciones en las líneas de investigación y desarrollo. </p><p>Interesa realizar investigación en la especificación, transformación, optimización y evaluación de algoritmos distribuidos y paralelos. Esto incluye el diseño y desarrollo de sistemas paralelos, la transformación de algoritmos secuenciales en paralelos, y las métricas de evaluación de performance sobre distintas plataformas de soporte (hardware y software). Más allá de las mejoras constantes en las arquitecturas físicas de soporte, uno de los mayores desafíos se centra en cómo aprovechar al máximo la potencia de las mismas. </p></div></div></div></div>',1),xd=[gd];function bd(e,t){return ot(),at("div",vd,xd)}const yd=Pt(hd,[["render",bd]]),_d=[{path:"/",name:"Unidad1",alias:"/",component:Oc},{path:"/unidad2",name:"Unidad2",alias:"/unidad2",component:Bc},{path:"/unidad3",name:"Unidad3",alias:"/unidad3",component:ud},{path:"/unidad4",name:"Unidad4",alias:"/unidad4",component:yd}],wd=uc({history:Pl(),routes:_d}),_a=kr(cl);_a.use(wd);_a.mount("#app");
